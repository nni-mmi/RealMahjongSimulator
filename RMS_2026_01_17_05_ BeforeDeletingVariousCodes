# ã“ã‚Œã¯å‹•ã‹ãªã„ã€‚è‰²ã€…ã¨é€”ä¸­ã€‚ãŸã è‰²ã€…ãªã‚¯ãƒ©ã‚¹ãªã©ã‚’å‰Šé™¤ã™ã‚‹å‰ã«æ®‹ã—ã¦ãŠãã€‚
#ã€ŒPlayerStateã€ã€ŒDoraManagerã€ã€ŒDoraIndicator_as_meaningã€ã€ŒPlayer.Wallã€ã€Œskip_column()ã€ãªã©ã‚’æ¶ˆã™å‰

import random

# ===============================
# ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›ãƒ©ãƒƒãƒ‘ãƒ¼
# ===============================
class Logger:
    def __init__(self, enabled=True):
        self.enabled = enabled

    def log(self, *args, **kwargs):
        if self.enabled:
            formatted_args = []
            for arg in args:
                if isinstance(arg, list):
                    formatted_args.append(", ".join(str(a) for a in arg))
                elif isinstance(arg, dict):
                    formatted_args.append(", ".join(f"{k}:{v}" for k, v in arg.items()))
                else:
                    formatted_args.append(str(arg))
            print(*formatted_args, **kwargs)

logger = Logger(enabled=True)

# ===============================
# ã‚²ãƒ¼ãƒ ã®æ®µéš
# ===============================
from enum import Enum, auto

class GamePhase(Enum):
    INIT = auto()
    KARITON = auto()
    TEMP_PARENT = auto()
    REAL_PARENT = auto()
    WALL_BUILD = auto()
    KAIMEN = auto()
    DONE = auto()

# ===============================
# é †ç•ªã¨åº§æ¨™ ï¼ OrderAndCoordinates
# ===============================
class TableOrder:
    wind_order = ["æ±", "å—", "è¥¿", "åŒ—"]                            # é¢¨ã®ä¸¦ã³ç•ª
    sides = {"A": (1, 0), "B": (0, -1), "C": (-1, 0), "D": (0, 1)} # å“ã®åº§æ¨™å®šç¾©
    clockwise_order = ["A", "D", "C", "B"]                         # ç”»é¢åº§æ¨™ç³»ã«åˆã‚ã›ãŸæ™‚è¨ˆå›ã‚Š
    counter_clockwise_order = ["A", "B", "C", "D"]                 # åŒã˜ãã®åæ™‚è¨ˆå›ã‚Š

    # æ™‚è¨ˆå›ã‚Š
    @staticmethod
    def next_clockwise(side):
        idx = TableOrder.clockwise_order.index(side)
        return TableOrder.clockwise_order[(idx + 1) % 4]

    # åŠæ™‚è¨ˆå›ã‚Š
    @staticmethod
    def next_counter_clockwise(side):
        idx = TableOrder.counter_clockwise_order.index(side)
        return TableOrder.counter_clockwise_order[(idx + 1) % 4]

# ===============================
# ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
# ===============================
from dataclasses import dataclass, field
from typing import List

# ===============================
# å„ç¨®ã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å®šç¾©
# ===============================
# ä»®æ±æ±ºã‚ã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
@dataclass
class KaritonDecisionEvent:
    kariton_player: Player
    mixer: Player

# è¦ªæ±ºã‚ã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
@dataclass
class ParentDecisionEvent:
    temp_parent: Player
    parent: Player
    temp_parent_decision_dice: tuple[int, int]
    parent_decision_dice: tuple[int, int]

# æ´—ç‰Œã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
@dataclass(frozen=True)
class WallShuffledEvent:
    tiles: List[str]

# ç Œç‰Œã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
@dataclass(frozen=True)
class WallBuiltEvent:
    player: str
    wall_columns: int  # ä½•åˆ—ç©ã‚“ã ã‹

# é–‹é–€ã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
@dataclass(frozen=True)
class KaimenEvent:
    parent: str
    target: str
    total: int
    d1: int
    d2: int

# é…ç‰Œã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
@dataclass(frozen=True)
class TilesDealtEvent:
    player: str
    tiles: List[str]

# ãƒ‰ãƒ©è¡¨ç¤ºã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
@dataclass(frozen=True)
class DoraRevealedEvent:
    indicator: str
    dora: str

# ===============================
# ã‚¤ãƒ™ãƒ³ãƒˆç®¡ç†ã‚¯ãƒ©ã‚¹
# ===============================
class EventManager:
    def __init__(self):
        self.events: List = []

    def push(self, event):
        self.events.append(event)

# ===============================
# éº»é›€å“ã‚„å¸­ã‚„å ´é¢¨ã®ç®¡ç†
#  ->æœ€æ—©åãŒä½“ã‚’è¡¨ã—ã¦ãŠã‚‰ãšè¦æ”¹åãªæ°—é…ã€‚ã‚ã¨ã¡ã‚‡ã£ã¨ç¥ã‚¯ãƒ©ã‚¹è‡­ã§åˆ†å‰²æ¤œè¨
# â€»ãƒ†ã‚¹ãƒˆçš„ã«ã“ã®ã‚¯ãƒ©ã‚¹ã®ã¿ã‚³ãƒ¡ãƒ³ãƒˆã‚’ã‹ãªã‚Šæ›¸ã„ã¦ã¿ã‚‹
# ===============================
class SeatingManager:
    def __init__(self, players):
        self.players = players
        self.seat_to_player = {}  # å…ƒã€…kariton_orderã€å…ƒseat_assignment ä»–æ¡ˆseatingã€seated_players

    # é¢¨ç‰Œã‚’ç”¨æ„
    wind_tiles = ["æ±", "å—", "è¥¿", "åŒ—"]

    # å¸­ã‹ã‚‰ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å¾—ã‚‹
    def player_at(self, seat):
        return self.seat_to_player[seat]

    # ä»®æ±ã®æ±ºå®š
    def decide_kariton(self) -> KaritonDecisionEvent:
        # æ··ãœãŸé¢¨ç‰Œã‚’å„äººãŒå–ã‚‹
        mixer = random.choice(self.players)       # é¢¨ç‰Œã‚’æ··ãœã‚‹äººã‚’ä¹±æ•°ã§é¸å®š
        drawn = random.sample(self.wind_tiles, 4) # é¢¨ç‰Œé›†åˆã‚’ä¹±æ•°ã§æ··ãœã‚‹
        for p, w in zip(self.players, drawn):     # ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«æ··ãœæ¸ˆã¿é¢¨ç‰Œé›†åˆã‚’zipã§å‰²ã‚Šå½“ã¦
            p.initial_wind = w                    # ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®åˆæœŸé¢¨é…ç½®ã«é¢¨ç‰Œã‚’å‰²ã‚Šå½“ã¦ã‚‹éƒ¨åˆ†

        # ä»®æ±ã¨ä»®æ±ã®å¸­ãŒç¢ºå®š
        kariton_player = next(p for p in self.players if p.initial_wind == "æ±") # ä»®æ±ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å¾—ã‚‹
        kariton_player.seat = random.choice(["A", "B", "C", "D"])                # ä»®æ±ã®åº§å¸­ã‚’ä¹±æ•°æ±ºå®š
        kariton_player.is_kariton = True                                         # ä»®æ±ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹

        # å„äººãŒå–å¾—é¢¨ç‰Œã«åŸºã¥ã„ã¦åº§å¸­ã«åº§ã‚‹
        self.seat_to_player[kariton_player.seat] = kariton_player       # å¸­ã‹ã‚‰äººè¾æ›¸ã«ä»®æ±ã¨ãã®å¸­ã‚’ç™»éŒ²
        seat = kariton_player.seat                                      # åŸºæº–ã¨ãªã‚‹ä»®æ±ã®å¸­ã‚’seatã«è¨­å®š
        for wind in ["å—", "è¥¿", "åŒ—"]:                                  # wind in å—è¥¿åŒ—é †ã«forå‡¦ç†ã™ã‚‹
            seat = TableOrder.next_counter_clockwise(seat)              # seatã®åæ™‚è¨ˆå›ã‚Šã§æ¬¡ã®å¸­ã‚’seatã«
            p = next(p for p in self.players if p.initial_wind == wind) # åˆæœŸé¢¨ãŒç¾åœ¨ã®windã®äººã‚’èµ°æŸ»æ¤œç´¢
            p.seat = seat                                               # ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¸­ã«seatã‚’ã‚»ãƒƒãƒˆ
            self.seat_to_player[seat] = p                               # å¸­ã‹ã‚‰äººè¾æ›¸[å¸­]ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ç™»éŒ²

        return KaritonDecisionEvent(
            kariton_player=kariton_player,
            mixer=mixer
        )

    # ä»®è¦ªæ±ºå®šã¨è¦ªæ±ºå®š
    def decide_parent(self) -> ParentDecisionEvent:
        # ä»®è¦ªæ±ºå®šéƒ¨
        kariton_seat = next(s for s, p in self.seat_to_player.items() if p.is_kariton) # ä»®æ±ã®å¸­ã‚’å¾—ã‚‹
        temp_parent_seat, _, d1, d2 = Dice.roll_and_get_target(kariton_seat)           # ä»®è¦ªæ±ºè³½,ä»®è¦ªå¸­å¾—
        temp_parent = self.seat_to_player[temp_parent_seat]                            # ä»®è¦ª=è¾æ›¸[ä»®è¦ªå¸­]

        # è¦ªæ±ºå®šéƒ¨
        parent_seat, _, rd1, rd2 = Dice.roll_and_get_target(temp_parent.seat)  # è¦ªæ±ºè³½æŒ¯ã‚Šã€è¦ªå¸­å¾—ã‚‹
        parent = self.seat_to_player[parent_seat]                              # è¦ªï¼å¸­â†’äººè¾æ›¸[è¦ªå¸­]
        parent.is_parent = True                                                # è¦ªã®è¦ªãƒ•ãƒ©ã‚°ã‚’ã‚ªãƒ³

        self.assign_winds(parent.seat)

        return ParentDecisionEvent(
            temp_parent=temp_parent,
            parent=parent,
            temp_parent_decision_dice=(d1, d2),
            parent_decision_dice=(rd1, rd2),
        )

    # å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å ´é¢¨ã‚’å‰²ã‚Šå½“ã¦ã‚‹
    def assign_winds(self, parent_seat):
        parent = self.seat_to_player[parent_seat]                   # è¦ª=å¸­â†’äººè¾æ›¸[è¦ªå¸­]
        parent.wind = "æ±"                                          # è¦ªã«æ±ã®å ´é¢¨ã‚’å‰²ã‚Šå½“ã¦
        idx = TableOrder.counter_clockwise_order.index(parent_seat) # ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«è¦ªå¸­ã‚’è¨­å®š
        for wind in ["å—", "è¥¿", "åŒ—"]:                              # wind in å—è¥¿åŒ—ã§for
            idx = (idx + 1) % 4                                     # idxã‚’1é€²ã‚â†“ãã®äººã®é¢¨ã‚’â†‘ã«.
        self.seat_to_player[TableOrder.counter_clockwise_order[idx]].wind = wind

    # ãƒ€ã‚¤ã‚¹ã§åº§å¸­ã‚’å¾—ã‚‹ã®ã§ã¯ç„¡ãã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å¾—ã‚‹ãƒ©ãƒƒãƒ‘ãƒ¼
    def target_player_by_dice(self, roller_seat, d1, d2):
        target_seat = Dice.target_seat_from_total(roller_seat, d1 + d2)
        return self.player_at(target_seat)

# ===============================
# ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¯ãƒ©ã‚¹
# ===============================
kana_chars = list("ã‚¢ã‚¤ã‚¦ã‚¨ã‚ªã‚«ã‚­ã‚¯ã‚±ã‚³ã‚µã‚·ã‚¹ã‚»ã‚½ã‚¿ãƒãƒ„ãƒ†ãƒˆãƒŠãƒ‹ãƒŒãƒãƒãƒãƒ’ãƒ•ãƒ˜ãƒ›ãƒãƒŸãƒ ãƒ¡ãƒ¢ãƒ¤ãƒ¦ãƒ¨ãƒ©ãƒªãƒ«ãƒ¬ãƒ­ãƒ¯ãƒ²ãƒ³ã‚¬ã‚®ã‚°ã‚²ã‚´ã‚¶ã‚¸ã‚ºã‚¼ã‚¾ãƒ€ãƒ‚ãƒ…ãƒ‡ãƒ‰ãƒãƒ“ãƒ–ãƒ™ãƒœãƒ‘ãƒ”ãƒ—ãƒšãƒ")

class Player:
    def __init__(self, name, type_="CPU"):
        self.name = name
        self.type = type_
        self.initial_wind = None  # ä»®ã§å¼•ã„ãŸé¢¨ç‰Œ
        self.seat = None  # A/B/C/D å¸­ï¼ˆå ´é¢¨ã¨ã¯åˆ¥ï¼‰
        self.wind = None  # æ±å—è¥¿åŒ—ï¼ˆæœ€çµ‚çš„ãªå®¶ï¼‰
        self.is_kariton = False
        self.is_parent = False
        self.wall = None  # Wallã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        self.hand_tiles = HandTiles()

    def __repr__(self):
        return f"{self.name}({self.type}, seat={self.seat}, wind={self.wind})"

    @staticmethod
    def generate_player_name():
        return "".join(random.choices(kana_chars, k=random.randint(2, 4)))

# ===============================
# ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼
# ===============================
class PlayerFactory:
    @staticmethod
    def create_players():
        players = [Player(Player.generate_player_name()) for _ in range(3)]
        players.append(Player("ã‚ãªãŸ", type_="Human"))
        random.shuffle(players)
        return players

# ===============================
# å±€å˜ä½ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®çŠ¶æ…‹ã®æŠ½è±¡åˆ†é›¢
# ===============================
class PlayerState:
    def __init__(self):
        # self.hand_tiles = HandTiles() æœ‰åŠ¹ã«ã™ã‚‹éš›ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰HandTilesã‚’æ¶ˆã™
        self.discards = DiscardTiles()
        self.melds = []

# ===============================
# ã‚µã‚¤ã‚³ãƒ­åˆ¤å®šå‡¦ç†
# ===============================
class Dice:
    @staticmethod
    def roll():
        return random.randint(1, 6), random.randint(1, 6)

    @staticmethod
    def get_target_player_by_total(roller_seat, total):
        """ã‚µã‚¤ã‚³ãƒ­åˆè¨ˆå€¤ã‹ã‚‰å¯¾è±¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¾ºã‚’è¿”ã™"""
        move_table = {
            (5, 9): 0,
            (2, 6, 10): 1,
            (3, 7, 11): 2,
            (4, 8, 12): 3
        }

        steps = None
        for nums, step in move_table.items():
            if total in nums:
                steps = step
                break

        # åæ™‚è¨ˆå›ã‚Šã®é †ã«å¾“ã£ã¦å¯¾è±¡è€…ã‚’æ±ºå®š
        idx = TableOrder.counter_clockwise_order.index(roller_seat)
        target_side = TableOrder.counter_clockwise_order[(idx + steps) % 4]
        return target_side

    @staticmethod
    def roll_and_get_target(roller_seat):
        """ã‚µã‚¤ã‚³ãƒ­ã‚’1å›æŒ¯ã‚Šã€å¯¾è±¡ã®å¸­ã¨åˆè¨ˆå€¤ã¨ãƒ€ã‚¤ã‚¹ãã‚Œãã‚Œã®å€¤ã‚’è¿”ã™ã€‚ç´”ç²‹ãªæ‰‹ç¶šãã®å…±é€šåŒ–"""
        d1, d2 = Dice.roll()
        total = d1 + d2
        target = Dice.get_target_player_by_total(roller_seat, total)
        return target, total, d1, d2

DiceResult = namedtuple("DiceResult", "target_seat d1 d2 total")

def roll_for_seat(roller_seat) -> DiceResult:
    d1, d2 = Dice.roll()
    total = d1 + d2
    target_seat = Dice.target_seat_from_total(roller_seat, total)
    return DiceResult(target_seat, d1, d2, total)

# ===============================
# ä½¿ç”¨éº»é›€ç‰Œã®å®šç¾©ï¼ˆåŸºæœ¬çš„ã«å¤‰æ›´ç¦æ­¢ï¼šå‰æã‚„æ–¹é‡ãŒãƒ–ãƒ¬ã‚‹ç‚ºï¼‰
# ===============================
tiles = "ğŸ€‡,ğŸ€‡,ğŸ€‡,ğŸ€‡,ğŸ€ˆ,ğŸ€ˆ,ğŸ€ˆ,ğŸ€ˆ,ğŸ€‰,ğŸ€‰,ğŸ€‰,ğŸ€‰,ğŸ€Š,ğŸ€Š,ğŸ€Š,ğŸ€Š,ğŸ€‹èµ¤,ğŸ€‹,ğŸ€‹,ğŸ€‹,ğŸ€Œ,ğŸ€Œ,ğŸ€Œ,ğŸ€Œ,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€™,ğŸ€™,ğŸ€™,ğŸ€™,ğŸ€š,ğŸ€š,ğŸ€š,ğŸ€š,ğŸ€›,ğŸ€›,ğŸ€›,ğŸ€›,ğŸ€œ,ğŸ€œ,ğŸ€œ,ğŸ€œ,ğŸ€èµ¤,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€Ÿ,ğŸ€Ÿ,ğŸ€Ÿ,ğŸ€Ÿ,ğŸ€ ,ğŸ€ ,ğŸ€ ,ğŸ€ ,ğŸ€¡,ğŸ€¡,ğŸ€¡,ğŸ€¡,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€‘,ğŸ€‘,ğŸ€‘,ğŸ€‘,ğŸ€’,ğŸ€’,ğŸ€’,ğŸ€’,ğŸ€“,ğŸ€“,ğŸ€“,ğŸ€“,ğŸ€”èµ¤,ğŸ€”,ğŸ€”,ğŸ€”,ğŸ€•,ğŸ€•,ğŸ€•,ğŸ€•,ğŸ€–,ğŸ€–,ğŸ€–,ğŸ€–,ğŸ€—,ğŸ€—,ğŸ€—,ğŸ€—,ğŸ€˜,ğŸ€˜,ğŸ€˜,ğŸ€˜,ğŸ€€,ğŸ€€,ğŸ€€,ğŸ€€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€‚,ğŸ€‚,ğŸ€‚,ğŸ€‚,ğŸ€ƒ,ğŸ€ƒ,ğŸ€ƒ,ğŸ€ƒ,ğŸ€†,ğŸ€†,ğŸ€†,ğŸ€†,ğŸ€…,ğŸ€…,ğŸ€…,ğŸ€…,ğŸ€„,ğŸ€„,ğŸ€„,ğŸ€„"

meaning = {
    "ğŸ€‡": "1m", "ğŸ€ˆ": "2m", "ğŸ€‰": "3m", "ğŸ€Š": "4m",
    "ğŸ€‹": "5m", "ğŸ€Œ": "6m", "ğŸ€": "7m", "ğŸ€": "8m", "ğŸ€": "9m",
    "ğŸ€‹èµ¤": "5mRed",

    "ğŸ€™": "1p", "ğŸ€š": "2p", "ğŸ€›": "3p", "ğŸ€œ": "4p",
    "ğŸ€": "5p", "ğŸ€": "6p", "ğŸ€Ÿ": "7p", "ğŸ€ ": "8p", "ğŸ€¡": "9p",
    "ğŸ€èµ¤": "5pRed",

    "ğŸ€": "1s", "ğŸ€‘": "2s", "ğŸ€’": "3s", "ğŸ€“": "4s",
    "ğŸ€”": "5s", "ğŸ€•": "6s", "ğŸ€–": "7s", "ğŸ€—": "8s", "ğŸ€˜": "9s",
    "ğŸ€”èµ¤": "5sRed",

    "ğŸ€€": "ton", "ğŸ€": "nan", "ğŸ€‚": "sha", "ğŸ€ƒ": "pei",
    "ğŸ€†": "haku", "ğŸ€…": "hatsu", "ğŸ€„": "chun"
}

# ===============================
# å£ç‰Œã®æ§‹é€ 
# ===============================
class Wall:
    def __init__(self):
        self.columns = []  # [[ä¸Š,ä¸‹], ...]

    def add_column(self, upper, lower):
        self.columns.append([upper, lower])

    def upper_row(self):
        return [col[0] for col in self.columns]

    def lower_row(self):
        return [col[1] for col in self.columns]

# ===============================
# å£ç‰Œã®ç®¡ç†
# ===============================
class WallManager:
    def __init__(self, seat_to_player, dice):
        self.seat_to_player = seat_to_player
        self.dice = dice

    # æ´—ç‰Œ = ç‰Œã‚’æ··ãœã‚‹
    def shipai(self):
        tile_list = [t.strip() for t in tiles.split(",")]
        random.shuffle(tile_list)
        return tile_list

    # ç Œç‰Œ = å£ç‰Œã‚’ç©ã‚€
    def chipai(self, tile_list):
        for p in self.seat_to_player.values():
            wall = Wall()
            for _ in range(17):
                upper, lower = tile_list.pop(0), tile_list.pop(0)
                wall.add_column(upper, lower)
            p.wall = wall

    # é–‹é–€ ï¼ åˆ‡ã‚Šå±±ã®ä½ç½®æ±ºå®š
    def kaimen(self, parent):
        target_side, total, d1, d2 = self.dice.roll_and_get_target(parent.seat)
        target = self.seat_to_player[target_side]
        return target, total, d1, d2

# ===============================
# å£ç‰Œ4ã¤ã‚’è¼ªã«è¦‹ç«‹ã¦ã¦ã€‚ã‚«ãƒ¼ã‚½ãƒ«ã¯æŒãŸãšã€æšæ•°ã‚’ç®¡ç†ã›ãšã€æ¬¡ã®å£ã¯ã©ã‚Œã‹ã‚’æ•™ãˆã‚‹ãŒè²¬å‹™
# ===============================
class WallRing:
    def __init__(self, seat_to_player):
        self.seat_to_player = seat_to_player
        self.order = TableOrder.clockwise_order

    def next_player(self, current_player):          # ã“ã“ã‚’next_wall(self, wall) ã«ã™ã‚‹
        idx = self.order.index(current_player.seat)
        next_seat = self.order[(idx + 1) % 4]
        return self.seat_to_player[next_seat]

# ===============================
# å£ç‰Œã‚«ãƒ¼ã‚½ãƒ«
# ===============================
class WallCursor:
    def __init__(self, seat_to_player, start_player, start_col):
        self.seat_to_player = seat_to_player
        self.current_player = start_player
        self.col = start_col  # å³ç«¯åŸºæº–ã§ã® index

    def _move_to_next_wall(self):
        side = TableOrder.next_clockwise(self.current_player.seat)
        self.current_player = self.seat_to_player[side]
        self.col = len(self.current_player.wall.columns) - 1

    def take_pair(self):
        """ä¸Šæ®µâ†’ä¸‹æ®µã®2æšã‚’å–ã‚‹"""
        if self.col < 0:
            self._move_to_next_wall()

        upper, lower = self.current_player.wall.columns[self.col]
        self.current_player.wall.columns[self.col] = [None, None]
        self.col -= 1
        return upper, lower

    def take_single(self, upper=True):
        if self.col < 0:
            self._move_to_next_wall()

        tile = self.current_player.wall.columns[self.col][0 if upper else 1]
        self.current_player.wall.columns[self.col][0 if upper else 1] = None
        return tile

# ===============================
# æ‰‹ç‰Œ
# ===============================
class HandTiles:
    def __init__(self):
        self.tiles = []

    def add(self, tile):
        self.tiles.append(tile)

    def __len__(self):
        return len(self.tiles)

    def __repr__(self):
        return " ".join(self.tiles)

# ===============================
# é…ç‰Œç®¡ç†
# ===============================
class HaipaiManager:
    def __init__(self, seat_to_player, parent, start_col):
        self.seat_to_player = seat_to_player
        self.parent = parent
        self.cursor = WallCursor(seat_to_player, parent, start_col)

    def players_ccw(self):
        order = []
        side = self.parent.seat
        for _ in range(4):
            order.append(self.seat_to_player[side])
            side = TableOrder.next_counter_clockwise(side)
        return order

    def deal_four_tiles(self):
        for p in self.players_ccw():
            for _ in range(2):
                u, l = self.cursor.take_pair()
                p.hand.add(u)
                p.hand.add(l)

    def take_chonchon(self):                     # è¦æ”¹ä¿®ã€‚
        players = self.players_ccw()
        parent = players[0]                      # ãã‚“ãªä¿è¨¼ã¯ã©ã“ã«ã‚‚ãªãã¦ã‚«ã‚¹

        t1 = self.cursor.take_single(upper=True) # cursor.skip_column()ã¯æœªå®šç¾©
        self.cursor.skip_column()                # ã‚ˆã—ã‚“ã°å®šç¾©ã—ã¦ã‚‚ã‚¹ã‚­ãƒƒãƒ—ã—ãŸå¾Œå…ƒã«æˆ»ã•ãªã„ã¨ã¨ã‹
        t2 = self.cursor.take_single(upper=True) # ãã†ã„ã†å®Ÿè£…ã§ãªã„ã«ã—ã¦ã‚‚æš—é»™ã«å¿…è¦ã¨ã™ã‚‹å¾Œå‡¦ç†ãŒå¢—ãˆã‚‹ã‹ã‚‰ãƒ€ãƒ¡

        parent.hand.add(t1)
        parent.hand.add(t2)

    def deal_initial(self):
        # 3å‘¨ Ã— 4æš
        for _ in range(3):
            self.deal_four_tiles()

        # ç‰¹æ®Šä¸€å‘¨
        players = self.players_ccw()

        # è¦ªï¼šãƒãƒ§ãƒ³ãƒãƒ§ãƒ³
        self.take_chonchon()

        # å­
        players[1].hand.add(self.cursor.take_single(upper=False))
        players[2].hand.add(self.cursor.take_single(upper=True))
        players[3].hand.add(self.cursor.take_single(upper=False))

# ===============================
# ç‹ç‰Œ
# ===============================
class Wanpai:
    def __init__(self, wall_columns):
        self.columns = wall_columns[:7]

    def dora_indicator(self):
        return self.columns[2][0]

# ===============================
# ãƒ‰ãƒ©åˆ¤å®šã€€ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å¾Œã®ãƒ•ã‚¡ã‚¤ãƒ«ã§ã¯DoraIndicatorä»¥å¤–ä¸€æ—¦æ¶ˆã™
# ===============================
class DoraManager:
    def __init__(self, wanpai):
        self.wanpai = wanpai
        self.indicators = [wanpai.reveal()]

    def kan(self):
        self.indicators.append(self.wanpai.reveal())

# meaningã«ä¾ã‚‹ãƒ‰ãƒ©åˆ¤å®š
class DoraIndicator_as_meaning:
    @staticmethod
    def next(tile):
        base = tile.replace("èµ¤", "")
        m = meaning[base]

        if m[0].isdigit():
            num = int(m[0])
            suit = m[1]
            next_num = 1 if num == 9 else num + 1
            return next(t for t, v in meaning.items() if v == f"{next_num}{suit}")

        winds = ["ton", "nan", "sha", "pei"]
        if m in winds:
            return next(t for t, v in meaning.items()
                        if v == winds[(winds.index(m) + 1) % 4])

        dragons = ["haku", "hatsu", "chun"]
        return next(t for t, v in meaning.items()
                    if v == dragons[(dragons.index(m) + 1) % 3])

# çµµæ–‡å­—ã«ä¾ã‚‹ãƒ‰ãƒ©åˆ¤å®š
class DoraIndicator:
    @staticmethod
    def next(tile):
        if tile in "ğŸ€‡ğŸ€ˆğŸ€‰ğŸ€ŠğŸ€‹ğŸ€ŒğŸ€ğŸ€ğŸ€":
            nums = ["ğŸ€‡", "ğŸ€ˆ", "ğŸ€‰", "ğŸ€Š", "ğŸ€‹", "ğŸ€Œ", "ğŸ€", "ğŸ€", "ğŸ€"]
            return nums[(nums.index(tile) + 1) % 9]

        if tile in "ğŸ€™ğŸ€šğŸ€›ğŸ€œğŸ€ğŸ€ğŸ€ŸğŸ€ ğŸ€¡":
            nums = ["ğŸ€™", "ğŸ€š", "ğŸ€›", "ğŸ€œ", "ğŸ€", "ğŸ€", "ğŸ€Ÿ", "ğŸ€ ", "ğŸ€¡"]
            return nums[(nums.index(tile) + 1) % 9]

        if tile in "ğŸ€ğŸ€‘ğŸ€’ğŸ€“ğŸ€”ğŸ€•ğŸ€–ğŸ€—ğŸ€˜":
            nums = ["ğŸ€", "ğŸ€‘", "ğŸ€’", "ğŸ€“", "ğŸ€”", "ğŸ€•", "ğŸ€–", "ğŸ€—", "ğŸ€˜"]
            return nums[(nums.index(tile) + 1) % 9]

        winds = ["ğŸ€€", "ğŸ€", "ğŸ€‚", "ğŸ€ƒ"]
        if tile in winds:
            return winds[(winds.index(tile) + 1) % 4]

        dragons = ["ğŸ€†", "ğŸ€…", "ğŸ€„"]
        return dragons[(dragons.index(tile) + 1) % 3]

# ===============================
# ä¸€å±€å˜ä½ã®ç®¡ç†ã€‚çŠ¶æ…‹ã‚’é€²ã‚ã€Eventã‚’ç”Ÿæˆï¼ˆUIã«è§¦ã‚Œãªã„ï¼‰
# ===============================
class Round:
    def __init__(self, players, dice):
        self.players = players
        self.dice = dice
        self.seating = SeatingManager(players)

    def start(self) -> list:
        events = []

        kariton_event = self.seating.decide_kariton()
        events.append(kariton_event)

        parent_event = self.seating.decide_parent()
        events.append(parent_event)

        wall_manager = WallManager(self.seating.seat_to_player, self.dice)
        tiles = wall_manager.shipai()
        events.append(WallShuffledEvent(tiles=tiles))

        wall_manager.chipai(tiles)
        for p in self.seating.seat_to_player.values():
            events.append(
                WallBuiltEvent(player=p.name, wall_columns=len(p.wall.columns))
            )

        target, total, d1, d2 = wall_manager.kaimen(parent_event.parent)
        events.append(KaimenEvent(
            parent=parent_event.parent.name,
            target=target.name,
            total=total,
            d1=d1,
            d2=d2
        ))

        # é…ç‰Œ
        start_col = len(target.wall.columns) - total - 1
        haipai = HaipaiManager(self.seating.seat_to_player, parent_event.parent, start_col)
        haipai.deal_initial()

        for p in self.seating.seat_to_player.values():
            events.append(
                TilesDealtEvent(player=p.name, tiles=p.hand.tiles.copy())
            )

        wanpai = Wanpai(target.wall.columns[-total:])
        indicator = wanpai.dora_indicator()
        events.append(
            DoraRevealedEvent(
                indicator=indicator,
                dora=DoraIndicator.next(indicator)
            )
        )

        return events

# ===============================
# å¸ä»¤å¡”ã€€class Application ã§ã‚‚ã„ã„ã‘ã©
# ===============================
class Game:
    def __init__(self, logger, dice):
        self.logger = logger
        self.dice = dice
        self.players = PlayerFactory.create_players()
        self.event_mgr = EventManager()
        self.log_manager = LogManager(logger)

    def run(self):
        scene = MatchScene(self)
        scene.enter()

# ===============================
# é·ç§»å‡¦ç†
# ===============================
class Scene:
    def enter(self): 
        pass

    def update(self): 
        pass

    def exit(self): 
        pass

class MatchScene(Scene):
    def __init__(self, game):
        self.game = game

    def enter(self):
        round = Round(self.game.players, self.game.dice)
        events = round.start()
        for e in events:
            self.game.event_mgr.push(e)
            self.game.log_manager.consume(e)
        self.game.log_manager.show_all_walls(round.seating.seat_to_player)

# ===============================
# è¡¨ç¤ºã®èª¿æ•´ã€€UIï¼ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å±¤ã€€æ–°æ—§æ··åœ¨ã ã—ãã‚‚ãã‚‚ã“ã®æ§‹é€ è‡ªä½“ãŒæ—§ã„ã€‚
# ===============================
class LogManager:
    def __init__(self, logger):
        self.logger = logger

    def consume(self, event):
        if isinstance(event, KaritonDecisionEvent):
            self.logger.log(
                f"ä»®æ±: {event.kariton_player.name} / æ··ãœãŸäºº: {event.mixer.name}"
            )
        elif isinstance(event, ParentDecisionEvent):
            self.logger.log(
                f"ä»®è¦ª: {event.temp_parent.name} â†’ è¦ª: {event.parent.name}"
            )
        elif isinstance(event, WallShuffledEvent):
            self.logger.log("æ´—ç‰Œå®Œäº†")
        elif isinstance(event, WallBuiltEvent):
            self.logger.log(
                f"{event.player} ã®å£ç‰Œï¼š{event.wall_columns} åˆ—"
            )
        elif isinstance(event, KaimenEvent):
            self.logger.log(
                f"é–‹é–€ï¼š{event.target}ï¼ˆå‡ºç›® {event.d1}+{event.d2}={event.total}ï¼‰"
            )
        elif isinstance(event, TilesDealtEvent):
            self.logger.log(
                f"{event.player} æ‰‹ç‰Œ: {' '.join(event.tiles)}"
            )
        elif isinstance(event, DoraRevealedEvent):
            self.logger.log(
                f"ãƒ‰ãƒ©è¡¨ç¤ºç‰Œ: {event.indicator} â†’ ãƒ‰ãƒ© {event.dora}"
            )

    def show_all_walls(self, seat_to_player):
        self.logger.log("\nâ”€â”€â”€ å…¨å“¡ã®å£ç‰Œ â”€â”€â”€")
        for wind in TableOrder.wind_order:
            for p in seat_to_player.values():
                if p.wind == wind:
                    self.logger.log(f"ã€{p.wind}å®¶ {p.name}ã€‘")
                    self.logger.log("ä¸Šæ®µï¼š" + " ".join(p.wall.upper_row()))
                    self.logger.log("ä¸‹æ®µï¼š" + " ".join(p.wall.lower_row()))

    def log_title(self, title):
        self.logger.log(f"\nâ”€â”€â”€ {title} â”€â”€â”€")

    def log_title_and_contents(self, title, contents):
        self.log_title(title)
        self.logger.log(f"\n" + contents)

    # ã€Œå¼•ã„ãŸé¢¨ç‰Œã€ã‚’é¢¨ã®ä¸¦ã³é †ã«ã‚½ãƒ¼ãƒˆè¡¨ç¤º
    def show_drawn_winds(self, players):
        self.log_title("å„ã€…ãŒå¼•ã„ãŸé¢¨ç‰Œ")
        sorted_players = sorted(
            players, key=lambda p: TableOrder.wind_order.index(p.initial_wind))
        self.logger.log(", ".join(f"{p.name}:{p.initial_wind}" for p in sorted_players))

    # å¸­è¡¨ç¤ºãƒ»å ´é¢¨è¡¨ç¤ºã‚’é¢¨ã®ä¸¦ã³é †ã«ã‚½ãƒ¼ãƒˆè¡¨ç¤º
    def show_seating_by_wind(self, seat_to_player):
        sorted_items = sorted(
            kariton_order.items(),
            key=lambda item: TableOrder.wind_order.index(item[1].wind)
        )
        for side, player in sorted_items:
            self.logger.log(f"{side} {player.name} ({player.wind})")

    # å¸­è¡¨ç¤ºãƒ»å ´é¢¨è¡¨ç¤ºã‚’åˆæœŸé¢¨ã®ä¸¦ã³é †ã«ã‚½ãƒ¼ãƒˆè¡¨ç¤º
    def show_seating_by_initial_wind(self, seat_to_player):
        sorted_items = sorted(
            kariton_order.items(),
            key=lambda item: TableOrder.wind_order.index(item[1].initial_wind)
        )
        for side, player in sorted_items:
            self.logger.log(f"{side} {player.name} ({player.initial_wind})")

    # ã‚µã‚¤ã‚³ãƒ­æ¼”å‡º
    def show_dice(self, roller_name, die1, die2):
        self.logger.log(f"â”€â”€â”€ {roller_name} ãŒã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã‚Šã¾ã—ãŸâ€¦â€¦")
        self.logger.log(f" {die1}ã€{die2} ï¼ å‡ºç›®åˆè¨ˆ {die1 + die2} â”€â”€â”€")

    # æ´—ç‰Œçµæœè¡¨ç¤º
    def show_shipai_result(self, tile_list):
        self.log_title("æ´—ç‰Œ")
        self.logger.log(f"ç¾åœ¨ã®ç‰Œä¸¦ã³: {', '.join(tile_list)}")
        self.logger.log(
            "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")

    # å£ç‰Œè¡¨ç¤º
    def show_wall(self, player):
        self.logger.log(f"ã€{player.wind}å®¶ã€€{player.name}ï¼ˆ{player.seat}å¸­ï¼‰ã®å£ç‰Œã€‘")
        self.logger.log("ä¸Šæ®µï¼š" + ", ".join(player.wall.upper_row()))
        self.logger.log("ä¸‹æ®µï¼š" + ", ".join(player.wall.lower_row()))
        self.logger.log(
            "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")

    # å…¨å“¡åˆ†ã®å£ç‰Œã‚’é¢¨ã®ä¸¦ã³é †ã§è¡¨ç¤º
    #def show_all_walls(self, seat_to_player):
    # for wind in TableOrder.wind_order:
    # for side, player in kariton_order.items():
    # if player.wind == wind:
    # self.show_wall(player)

    # é–‹é–€è¡¨ç¤º
    def show_kaimen_wall(self, player, total):
        self.log_title("é–‹é–€")
        idx = len(player.wall.columns) - total

        upper = player.wall.upper_row()
        lower = player.wall.lower_row()

        upper.insert(idx, " é–‹é–€ä½ç½® ")
        lower.insert(idx, " é–‹é–€ä½ç½® ")

        self.logger.log(f"ã€{player.wind}å®¶ã€€{player.name}ï¼ˆ{player.seat}å¸­ï¼‰ã®å£ç‰Œã€‘")
        self.logger.log("ä¸Šæ®µï¼š" + ", ".join(upper))
        self.logger.log("ä¸‹æ®µï¼š" + ", ".join(lower))

    # ã‚µã‚¤ã‚³ãƒ­æ¼”å‡º2 ç›®çš„ã®ç‚ºã«ã€åå‰ãŒã€ã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã‚Šã€å‡ºç›®äºŒã¤ã¯ã“ã‚Œã§åˆè¨ˆã¯ã“ã‚Œã§ã€çµæœã“ã†ã•
    def log_dice(self, roll_purpose, roller_name, die1, die2, result_message):
        self.logger.log(f"\nâ”€â”€â”€ {roll_purpose} ã®ç‚ºã« {roller_name} ãŒã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã‚Šã¾ã—ãŸâ€¦â€¦")
        self.logger.log(f"{die1}ã€{die2} ï¼ å‡ºç›®åˆè¨ˆ {die1 + die2}")
        self.logger.log(result_message)

# ===============================
# ãƒ¡ã‚¤ãƒ³å‡¦ç†
# ===============================
if __name__ == "__main__":
    Game(logger, Dice()).run()

