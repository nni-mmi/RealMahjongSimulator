import random

# ===============================
# ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›ãƒ©ãƒƒãƒ‘ãƒ¼
# ===============================
class Logger:
    def __init__(self, enabled=True):
        self.enabled = enabled

    def log(self, *args, **kwargs):
        if self.enabled:
            formatted_args = []
            for arg in args:
                if isinstance(arg, list):
                    formatted_args.append(", ".join(str(a) for a in arg))
                elif isinstance(arg, dict):
                    formatted_args.append(", ".join(f"{k}:{v}" for k, v in arg.items()))
                else:
                    formatted_args.append(str(arg))
            print(*formatted_args, **kwargs)

logger = Logger(enabled=True)

# ===============================
# ã‚²ãƒ¼ãƒ ã®æ®µéš
# ===============================
from enum import Enum, auto

class GamePhase(Enum):
    INIT = auto()
    KARITON = auto()
    TEMP_PARENT = auto()
    REAL_PARENT = auto()
    WALL_BUILD = auto()
    KAIMEN = auto()
    DONE = auto()

# ===============================
# é †ç•ªã¨åº§æ¨™ ï¼ OrderAndCoordinates
# ===============================
class TableOrder:
    # é¢¨ã®ä¸¦ã³ç•ª
    wind_order = ["æ±", "å—", "è¥¿", "åŒ—"]

    # å“ã®åº§æ¨™å®šç¾©
    sides = {"A": (1,0), "B": (0,-1), "C": (-1,0), "D": (0,1)}

    # ç”»é¢åº§æ¨™ç³»ã«åˆã‚ã›ãŸæ™‚è¨ˆå›ã‚Šãƒ»åæ™‚è¨ˆå›ã‚Š
    clockwise_order = ["A", "D", "C", "B"]
    counter_clockwise_order = ["A", "B", "C", "D"]
    
    # æ™‚è¨ˆå›ã‚Š
    @staticmethod
    def next_clockwise(side):
        idx = clockwise_order.index(side)
        return clockwise_order[(idx + 1) % 4]

    # åŠæ™‚è¨ˆå›ã‚Š
    @staticmethod
    def next_counter_clockwise(side):
        idx = counter_clockwise_order.index(side)
        return counter_clockwise_order[(idx + 1) % 4]

# ===============================
# éº»é›€å“ã‚„å¸­ã‚„å ´é¢¨ã®ç®¡ç†
# ===============================
class SeatingManager:
    def __init__(self, players):
        self.players = players
        self.kariton_order = {}

    # é¢¨ç‰Œã‚’ç”¨æ„
    wind_tiles = ["æ±", "å—", "è¥¿", "åŒ—"]

    # ä»®æ±ã®æ±ºå®š
    def decide_kariton(self):
        mixer = random.choice(self.players)
        drawn = random.sample(self.wind_tiles, 4)
        for p, w in zip(self.players, drawn):
            p.initial_wind = w

        east = next(p for p in self.players if p.initial_wind == "æ±")
        east.seat = random.choice(["A","B","C","D"])
        east.is_kariton = True

        self.kariton_order[east.seat] = east
        side = east.seat
        for wind in ["å—","è¥¿","åŒ—"]:
            side = TableOrder.next_counter_clockwise(side)
            p = next(p for p in self.players if p.initial_wind == wind)
            p.seat = side
            self.kariton_order[side] = p

        return mixer

    # ä»®è¦ªæ±ºå®šã¨è¦ªæ±ºå®š
    def decide_parent(self):
        east_side = next(s for s, p in self.kariton_order.items() if p.is_kariton)
        temp_side, _, d1, d2 = Dice.roll_and_get_target(east_side)

        temp_parent = self.kariton_order[temp_side]
        real_side, _, rd1, rd2 = Dice.roll_and_get_target(temp_parent.seat)
        real_parent = self.kariton_order[real_side]
        real_parent.is_parent = True

        self.assign_winds(real_parent.seat)

        return temp_parent, real_parent, d1, d2, rd1, rd2

    # å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å ´é¢¨ã‚’å‰²ã‚Šå½“ã¦ã‚‹
    def assign_winds(self, parent_side):
        parent = self.kariton_order[parent_side]
        parent.wind = "æ±"
        idx = TableOrder.counter_clockwise_order.index(parent_side)
        for wind in ["å—","è¥¿","åŒ—"]:
            idx = (idx + 1) % 4
            self.kariton_order[TableOrder.counter_clockwise_order[idx]].wind = wind

# ===============================
# ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¯ãƒ©ã‚¹
# ===============================
kana_chars = list("ã‚¢ã‚¤ã‚¦ã‚¨ã‚ªã‚«ã‚­ã‚¯ã‚±ã‚³ã‚µã‚·ã‚¹ã‚»ã‚½ã‚¿ãƒãƒ„ãƒ†ãƒˆãƒŠãƒ‹ãƒŒãƒãƒãƒãƒ’ãƒ•ãƒ˜ãƒ›ãƒãƒŸãƒ ãƒ¡ãƒ¢ãƒ¤ãƒ¦ãƒ¨ãƒ©ãƒªãƒ«ãƒ¬ãƒ­ãƒ¯ãƒ²ãƒ³ã‚¬ã‚®ã‚°ã‚²ã‚´ã‚¶ã‚¸ã‚ºã‚¼ã‚¾ãƒ€ãƒ‚ãƒ…ãƒ‡ãƒ‰ãƒãƒ“ãƒ–ãƒ™ãƒœãƒ‘ãƒ”ãƒ—ãƒšãƒ")

class Player:
    def __init__(self, name, type_="CPU"):
        self.name = name
        self.type = type_
        self.initial_wind = None  # ä»®ã§å¼•ã„ãŸé¢¨ç‰Œ
        self.seat = None          # A/B/C/D
        self.wind = None          # æ±å—è¥¿åŒ—ï¼ˆæœ€çµ‚çš„ãªå®¶ï¼‰
        self.is_kariton = False
        self.is_parent = False
        self.wall = None          # Wallã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ

    def __repr__(self):
        return f"{self.name}({self.type}, seat={self.seat}, wind={self.wind})"

    @staticmethod
    def generate_player_name():
        return "".join(random.choices(kana_chars, k=2))

# ===============================
# ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼
# ===============================
class PlayerFactory:
    @staticmethod
    def create_players():
        players = [Player(Player.generate_player_name()) for _ in range(3)]
        players.append(Player("ã‚ãªãŸ", type_="Human"))
        random.shuffle(players)
        return players

# ===============================
# ã‚µã‚¤ã‚³ãƒ­åˆ¤å®šå‡¦ç†
# ===============================
class Dice:
    @staticmethod
    def roll():
        return random.randint(1, 6), random.randint(1, 6)

    @staticmethod
    def get_target_player_by_total(roller_side, total):
        """ã‚µã‚¤ã‚³ãƒ­åˆè¨ˆå€¤ã‹ã‚‰å¯¾è±¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¾ºã‚’è¿”ã™"""
        move_table = {
            (5,9): 0,
            (2,6,10): 1,
            (3,7,11): 2,
            (4,8,12): 3
        }

        steps = None
        for nums, step in move_table.items():
            if total in nums:
                steps = step
                break

        # åæ™‚è¨ˆå›ã‚Šã®é †ã«å¾“ã£ã¦å¯¾è±¡è€…ã‚’æ±ºå®š
        idx = TableOrder.counter_clockwise_order.index(roller_side)
        target_side = TableOrder.counter_clockwise_order[(idx + steps) % 4]
        return target_side

    @staticmethod
    def roll_and_get_target(roller_side):
        """ã‚µã‚¤ã‚³ãƒ­ã‚’1å›æŒ¯ã‚Šã€å¯¾è±¡ã®è¾ºã¨åˆè¨ˆå€¤ã¨ãƒ€ã‚¤ã‚¹ãã‚Œãã‚Œã®å€¤ã‚’è¿”ã™ï¼ˆç´”ç²‹ãªæ‰‹ç¶šãã®å…±é€šåŒ–ï¼‰"""
        d1, d2 = Dice.roll()
        total = d1 + d2
        target = Dice.get_target_player_by_total(roller_side, total)
        return target, total, d1, d2

# ===============================
# ä½¿ç”¨éº»é›€ç‰Œã®å®šç¾©ï¼ˆåŸºæœ¬çš„ã«å¤‰æ›´ç¦æ­¢ï¼šå‰æã‚„æ–¹é‡ãŒãƒ–ãƒ¬ã‚‹ç‚ºï¼‰
# ===============================
tiles = "ğŸ€‡,ğŸ€‡,ğŸ€‡,ğŸ€‡,ğŸ€ˆ,ğŸ€ˆ,ğŸ€ˆ,ğŸ€ˆ,ğŸ€‰,ğŸ€‰,ğŸ€‰,ğŸ€‰,ğŸ€Š,ğŸ€Š,ğŸ€Š,ğŸ€Š,ğŸ€¢èµ¤5m,ğŸ€‹,ğŸ€‹,ğŸ€‹,ğŸ€Œ,ğŸ€Œ,ğŸ€Œ,ğŸ€Œ,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€™,ğŸ€™,ğŸ€™,ğŸ€™,ğŸ€š,ğŸ€š,ğŸ€š,ğŸ€š,ğŸ€›,ğŸ€›,ğŸ€›,ğŸ€›,ğŸ€œ,ğŸ€œ,ğŸ€œ,ğŸ€œ,ğŸ€£èµ¤5p,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€Ÿ,ğŸ€Ÿ,ğŸ€Ÿ,ğŸ€Ÿ,ğŸ€ ,ğŸ€ ,ğŸ€ ,ğŸ€ ,ğŸ€¡,ğŸ€¡,ğŸ€¡,ğŸ€¡,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€‘,ğŸ€‘,ğŸ€‘,ğŸ€‘,ğŸ€’,ğŸ€’,ğŸ€’,ğŸ€’,ğŸ€“,ğŸ€“,ğŸ€“,ğŸ€“,ğŸ€¤èµ¤5s,ğŸ€”,ğŸ€”,ğŸ€”,ğŸ€•,ğŸ€•,ğŸ€•,ğŸ€•,ğŸ€–,ğŸ€–,ğŸ€–,ğŸ€–,ğŸ€—,ğŸ€—,ğŸ€—,ğŸ€—,ğŸ€˜,ğŸ€˜,ğŸ€˜,ğŸ€˜,ğŸ€€,ğŸ€€,ğŸ€€,ğŸ€€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€‚,ğŸ€‚,ğŸ€‚,ğŸ€‚,ğŸ€ƒ,ğŸ€ƒ,ğŸ€ƒ,ğŸ€ƒ,ğŸ€†,ğŸ€†,ğŸ€†,ğŸ€†,ğŸ€…,ğŸ€…,ğŸ€…,ğŸ€…,ğŸ€„,ğŸ€„,ğŸ€„,ğŸ€„"

meaning = {
    "ğŸ€‡": "1m", "ğŸ€ˆ": "2m", "ğŸ€‰": "3m", "ğŸ€Š": "4m",
    "ğŸ€‹": "5m", "ğŸ€Œ": "6m", "ğŸ€": "7m", "ğŸ€": "8m", "ğŸ€": "9m",
    "ğŸ€¢èµ¤5m": "5mRed",

    "ğŸ€™": "1p", "ğŸ€š": "2p", "ğŸ€›": "3p", "ğŸ€œ": "4p",
    "ğŸ€": "5p", "ğŸ€": "6p", "ğŸ€Ÿ": "7p", "ğŸ€ ": "8p", "ğŸ€¡": "9p",
    "ğŸ€£èµ¤5p": "5pRed",

    "ğŸ€": "1s", "ğŸ€‘": "2s", "ğŸ€’": "3s", "ğŸ€“": "4s",
    "ğŸ€”": "5s", "ğŸ€•": "6s", "ğŸ€–": "7s", "ğŸ€—": "8s", "ğŸ€˜": "9s",
    "ğŸ€¤èµ¤5s": "5sRed",

    "ğŸ€€": "ton", "ğŸ€": "nan", "ğŸ€‚": "sha", "ğŸ€ƒ": "pei",
    "ğŸ€†": "haku", "ğŸ€…": "hatsu", "ğŸ€„": "chun"
}

# ===============================
# ç‰Œã‚’æ··ãœã¦å£ç‰Œã‚’ä½œã‚‹
# ===============================
class Wall:
    def __init__(self):
        self.columns = []  # [[ä¸Š,ä¸‹], ...]

    def add_column(self, upper, lower):
        self.columns.append([upper, lower])

    def upper_row(self):
        return [col[0] for col in self.columns]

    def lower_row(self):
        return [col[1] for col in self.columns]

# ===============================
# å£ç‰Œã®ç®¡ç†
# ===============================
class WallManager:
    def __init__(self, kariton_order, dice):
        self.kariton_order = kariton_order
        self.dice = dice

    # æ´—ç‰Œ = ç‰Œã‚’æ··ãœã‚‹
    def shipai(self):
        tile_list = [t.strip() for t in tiles.split(",")]
        random.shuffle(tile_list)
        return tile_list

    # ç Œç‰Œ = å£ç‰Œã‚’ç©ã‚€
    def chipai(self, tile_list):
        for p in self.kariton_order.values():
            wall = Wall()
            for _ in range(17):
                upper, lower = tile_list.pop(0), tile_list.pop(0)
                wall.add_column(upper, lower)
            p.wall = wall

    # é–‹é–€ ï¼ åˆ‡ã‚Šå±±ã®ä½ç½®æ±ºå®š
    def kaimen(self, parent):
        target_side, total, d1, d2 = self.dice.roll_and_get_target(parent.seat)
        target = self.kariton_order[target_side]
        return target, total, d1, d2

# ===============================
#  ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤éƒ¨
# ===============================
class Game:
    def __init__(self, logger, dice):
        self.logger = logger
        self.dice = dice
        self.players = PlayerFactory.create_players()
        self.seating = SeatingManager(self.players)
        self.phase = GamePhase.INIT
        self.log_manager = LogManager(logger)

    def run(self):
        self.phase = GamePhase.KARITON
        mixer = self.seating.decide_kariton()
        self.log_manager.show_drawn_winds(self.players)
        self.log_manager.show_seating_by_initial_wind(self.seating.kariton_order)
        # ã“ã“ã‚‰ã¸ã‚“ãƒ€ã‚¤ã‚¹æ¼”å‡ºã®ãƒ­ã‚°ã‚’å…¥ã‚Œã‚‹

        self.phase = GamePhase.TEMP_PARENT
        temp_parent, real_parent, *_ = self.seating.decide_parent()
        self.log_manager.show_seating_by_wind(self.seating.kariton_order)

        self.phase = GamePhase.WALL_BUILD
        wall_mgr = WallManager(self.seating.kariton_order, self.dice)
        tiles = wall_mgr.shipai()
        # ã“ã“ã«æ´—ç‰Œçµæœã‚’è¡¨ç¤ºã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—
        wall_mgr.chipai(tiles)
        # ã“ã“ã«ç Œç‰Œçµæœã‚’è¡¨ç¤ºã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—

        self.phase = GamePhase.KAIMEN
        target, total, *_ = wall_mgr.kaimen(real_parent)
        
        
        self.log_manager.show_kaimen_wall(real_parent, total)

# ===============================
# è¡¨ç¤ºã®èª¿æ•´ã€€UIï¼ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å±¤
# ===============================
class LogManager:
    def __init__(self, logger):
        self.logger = logger
    
    def log_title(self, title):
        self.logger.log(f"\nâ”€â”€â”€ {title} â”€â”€â”€")

    # ã€Œå¼•ã„ãŸé¢¨ç‰Œã€ã‚’é¢¨ã®ä¸¦ã³é †ã«ã‚½ãƒ¼ãƒˆè¡¨ç¤º
    def show_drawn_winds(self, players):
        self.log_title("å„ã€…ãŒå¼•ã„ãŸé¢¨ç‰Œ")
        sorted_players = sorted(
            players, key=lambda p: TableOrder.wind_order.index(p.initial_wind))
        self.logger.log(", ".join(f"{p.name}:{p.initial_wind}" for p in sorted_players))

    # å¸­è¡¨ç¤ºãƒ»å ´é¢¨è¡¨ç¤ºã‚’é¢¨ã®ä¸¦ã³é †ã«ã‚½ãƒ¼ãƒˆè¡¨ç¤º
    def show_seating_by_wind(self, kariton_order):
        sorted_items = sorted(
            kariton_order.items(),
            key=lambda item: TableOrder.wind_order.index(item[1].wind)
        )
        for side, player in sorted_items:
            self.logger.log(f"{side} {player.name} ({player.wind})")
    
    # å¸­è¡¨ç¤ºãƒ»å ´é¢¨è¡¨ç¤ºã‚’åˆæœŸé¢¨ã®ä¸¦ã³é †ã«ã‚½ãƒ¼ãƒˆè¡¨ç¤º
    def show_seating_by_initial_wind(self, kariton_order):
        sorted_items = sorted(
            kariton_order.items(),
            key=lambda item: TableOrder.wind_order.index(item[1].initial_wind)
        )
        for side, player in sorted_items:
            self.logger.log(f"{side} {player.name} ({player.initial_wind})")

    # ã‚µã‚¤ã‚³ãƒ­æ¼”å‡º
    def show_dice(self, roller_name, die1, die2):
        self.logger.log(f"â”€â”€â”€ {roller_name} ãŒã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã‚Šã¾ã—ãŸâ€¦â€¦")
        self.logger.log(f"               {die1}ã€{die2} ï¼ å‡ºç›®åˆè¨ˆ {die1 + die2} â”€â”€â”€")

    # æ´—ç‰Œçµæœè¡¨ç¤ºã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
    # æœªå®šç¾©

    # å£ç‰Œè¡¨ç¤ºã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
    def show_wall(self, player):
        self.logger.log(f"ã€{player.wind}å®¶ã€€{player.name}ï¼ˆ{player.seat}å¸­ï¼‰ã®å£ç‰Œã€‘")
        self.logger.log("ä¸Šæ®µï¼š" + ", ".join(player.wall.upper_row()))
        self.logger.log("ä¸‹æ®µï¼š" + ", ".join(player.wall.lower_row()))
        self.logger.log(
            "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")

    # å…¨å“¡åˆ†ã®å£ç‰Œã‚’é¢¨ã®ä¸¦ã³é †ã§è¡¨ç¤º
    def show_all_walls(self, kariton_order):
        for wind in TableOrder.wind_order:
            for side, player in kariton_order.items():
                if player.wind == wind:
                    show_wall(player)

    # é–‹é–€è¡¨ç¤º
    def show_kaimen_wall(self, player, total):
        log_title("é–‹é–€")
        idx = len(player.wall.columns) - total

        upper = player.wall.upper_row()
        lower = player.wall.lower_row()

        upper.insert(idx, "   é–‹é–€ä½ç½®   ")
        lower.insert(idx, "   é–‹é–€ä½ç½®   ")

        self.logger.log(f"ã€{player.wind}å®¶ã€€{player.name}ï¼ˆ{player.seat}å¸­ï¼‰ã®å£ç‰Œã€‘")
        self.logger.log("ä¸Šæ®µï¼š" + ", ".join(upper))
        self.logger.log("ä¸‹æ®µï¼š" + ", ".join(lower))

    # ã‚µã‚¤ã‚³ãƒ­ã®å‡ºç›®çµæœã‚’ä¸€åº¦ã ã‘è¨˜éŒ²ã™ã‚‹
    def log_dice(self, roll_purpose, roller_name, die1, die2, result_message):
        self.logger.log(f"\nâ”€â”€â”€ {roll_purpose} ã®ç‚ºã« {roller_name} ãŒã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã‚Šã¾ã—ãŸâ€¦â€¦")
        self.logger.log(f"{die1}ã€{die2} ï¼ å‡ºç›®åˆè¨ˆ {die1 + die2}")
        self.logger.log(result_message)

# ===============================
# ãƒ¡ã‚¤ãƒ³å‡¦ç†
# ===============================
if __name__ == "__main__":
    Game().run()
