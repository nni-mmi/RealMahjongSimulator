# RMS_2026_01_17_BeforeMajorModifications
#   ãƒ»ã¾ãšã“ã‚Œã¯å‹•ã‹ãªã„ã—ã€å¿…è¦ä¿®æ­£ç®‡æ‰€ã¯å±±ã»ã©ã‚ã‚‹
#   ãƒ»ä»Šå¾Œã®å¤‰æ›´äºˆå®šãªã©
#     ãƒ»æ–°æ—§æ··åœ¨â†’gitç®¡ç†ã—ã ã—ãŸã®ã§æ¬¡ã®ãƒ•ã‚¡ã‚¤ãƒ«ã§ã¯æ—§ã¯å‰Šé™¤ã—ã¦è‰¯ã„
#     ãƒ»ãƒªã‚¢ãƒ«éº»é›€ã§ã¯ç Œç‰Œæ™‚ç‚¹ã§å£ç‰Œã®ç‰©ç†çš„ä½ç½®ãŒæ±ºå®šã—ã¦ã„ã‚‹â†’å†ç¾ã™ã‚‹
#     ãƒ»ãƒãƒ§ãƒ³ãƒãƒ§ãƒ³ã¯é…ç‰Œ4å‘¨ç›®ã§å„äººãŒä¸€æšå–ã‚‹â†’è¦ªã ã‘5å‘¨ç›®ã‚’å–ã‚‹ã§ã‚‚å†ç¾ã§ãã‚‹ãŒã€å®Ÿéš›ã®ãƒãƒ§ãƒ³ãƒãƒ§ãƒ³ã¯è¦ªãŒ4å‘¨ç›®ã§2æšå–ã‚‹ã®ã§ã€ãŸã¨ãˆçµæœãŒåŒã˜ã§ã‚‚ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¨ã—ã¦ãã“ã¯å†ç¾ã™ã‚‹
#     ãƒ»LogManagerã‚’å»ƒæ­¢ã—ã¦UIã‚’ã‚¤ãƒ™ãƒ³ãƒˆã‚’æ¶ˆè²»ã™ã‚‹å½¢ã«ã™ã‚‹ã€€ãã‚Œã«åˆã‚ã›ã¦å‡¦ç†ã¨æç”»ã®çµåˆéƒ¨åˆ†ã‚’å‰¥ãŒã—ã¦ã„ã
#     ãƒ»Diceã‚„ã€ä»Šå¾Œå®Ÿè£…ã™ã‚‹ã§ã‚ã‚ã†ç‚¹æ£’ãªã©ã«ã¤ã„ã¦ã‚‚ã€MahjongTableãŒæŒã¤ã¹ãã‹ã‚‚ã—ã‚Œãªã„ã­
#     ãƒ»å¤šãã®ã“ã¨ã¯MahjongTableã‚’é€šã˜ã¦è¡Œã‚ã‚Œã‚‹å½¢ã«ã™ã‚‹ãŒã€ãã®å½¹å‰²ã€é–¢å¿ƒã€è²¬å‹™ã«ã¯å¸¸ã«æ³¨æ„ã‚’å‘ã‘ã€ç¥ã‚¯ãƒ©ã‚¹ã«ãªã‚‰ãªã„æ§˜ã«ã€‚
#   ãƒ»ã¾ããã®ä»–ã¯wikiã«æ›¸ãã‹

import random

# ===============================
# ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›ãƒ©ãƒƒãƒ‘ãƒ¼
# ===============================
class Logger:
    def __init__(self, enabled=True):
        self.enabled = enabled

    def log(self, *args, **kwargs):
        if self.enabled:
            formatted_args = []
            for arg in args:
                if isinstance(arg, list):
                    formatted_args.append(", ".join(str(a) for a in arg))
                elif isinstance(arg, dict):
                    formatted_args.append(", ".join(f"{k}:{v}" for k, v in arg.items()))
                else:
                    formatted_args.append(str(arg))
            print(*formatted_args, **kwargs)

logger = Logger(enabled=True)

# ===============================
# ã‚²ãƒ¼ãƒ ã®æ®µéš
# ===============================
from enum import Enum, auto

class GamePhase(Enum):
    INIT = auto()
    KARITON = auto()
    TEMP_PARENT = auto()
    REAL_PARENT = auto()
    WALL_BUILD = auto()
    KAIMEN = auto()
    DONE = auto()

# ===============================
# é †ç•ªã¨åº§æ¨™ ï¼ OrderAndCoordinates
# ===============================
class TableOrder:
    wind_order = ["æ±", "å—", "è¥¿", "åŒ—"]                             # é¢¨ã®ä¸¦ã³ç•ª
    sides = {"A": (1, 0), "B": (0, -1), "C": (-1, 0), "D": (0, 1)}  # å“ã®åº§æ¨™å®šç¾©
    clockwise_order = ["A", "D", "C", "B"]                          # ç”»é¢åº§æ¨™ç³»ã«åˆã‚ã›ãŸæ™‚è¨ˆå›ã‚Š
    counter_clockwise_order = ["A", "B", "C", "D"]                  # åŒã˜ãã®åæ™‚è¨ˆå›ã‚Š

    # æ™‚è¨ˆå›ã‚Š
    @staticmethod
    def next_clockwise(side):
        idx = TableOrder.clockwise_order.index(side)
        return TableOrder.clockwise_order[(idx + 1) % 4]

    # åŠæ™‚è¨ˆå›ã‚Š
    @staticmethod
    def next_counter_clockwise(side):
        idx = TableOrder.counter_clockwise_order.index(side)
        return TableOrder.counter_clockwise_order[(idx + 1) % 4]

# ===============================
# ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
# ===============================
from dataclasses import dataclass, field
from typing import List

# ===============================
# å„ç¨®ã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å®šç¾©
# ===============================
# ä»®æ±æ±ºã‚ã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
@dataclass
class KaritonDecisionEvent:
    kariton_player: Player
    mixer: Player

# è¦ªæ±ºã‚ã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
@dataclass
class ParentDecisionEvent:
    temp_parent: Player
    parent: Player
    temp_parent_decision_dice: tuple[int, int]
    parent_decision_dice: tuple[int, int]

# æ´—ç‰Œã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
@dataclass(frozen=True)
class ShipaiEvent:
    tiles: List[str]

# ç Œç‰Œã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
@dataclass(frozen=True)
class ChipaiEvent:
    player: str
    wall_columns: int  # ä½•åˆ—ç©ã‚“ã ã‹

# é–‹é–€ã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
@dataclass(frozen=True)
class KaimenEvent:
    parent: str
    target: str
    total: int
    d1: int
    d2: int

# é…ç‰Œã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
@dataclass(frozen=True)
class HaipaiEvent:
    player: str
    tiles: List[str]

# ãƒ‰ãƒ©è¡¨ç¤ºã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
@dataclass(frozen=True)
class DoraRevealedEvent:
    indicator: str
    dora: str

# ãƒ€ã‚¤ã‚¹ãƒ­ãƒ¼ãƒ«çµæœ
@dataclass(frozen=True)
class DiceResult:
    target_seat: str
    d1: int
    d2: int
    total: int 

# ===============================
# ã‚¤ãƒ™ãƒ³ãƒˆç®¡ç†ã‚¯ãƒ©ã‚¹
# ===============================
class EventManager:
    def __init__(self):
        self.events: List = []

    def push(self, event):
        self.events.append(event)

# ===============================
# ã‚µã‚¤ã‚³ãƒ­åˆ¤å®šå‡¦ç†
# ===============================
class Dice:
    @staticmethod
    def roll():
        return random.randint(1, 6), random.randint(1, 6)

    @staticmethod
    def get_target_player_by_total(roller_seat, total):
        """ã‚µã‚¤ã‚³ãƒ­åˆè¨ˆå€¤ã‹ã‚‰å¯¾è±¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¾ºã‚’è¿”ã™"""
        move_table = {
            (5, 9): 0,
            (2, 6, 10): 1,
            (3, 7, 11): 2,
            (4, 8, 12): 3
        }

        steps = None
        for nums, step in move_table.items():
            if total in nums:
                steps = step
                break

        steps = next(step for nums, step in table.items() if total in nums)

        # åæ™‚è¨ˆå›ã‚Šã®é †ã«å¾“ã£ã¦å¯¾è±¡è€…ã‚’æ±ºå®š
        idx = TableOrder.counter_clockwise_order.index(roller_seat)
        target_side = TableOrder.counter_clockwise_order[(idx + steps) % 4]
        return target_side

    @staticmethod
    def roll_and_get_target(roller_seat):
        """ã‚µã‚¤ã‚³ãƒ­ã‚’1å›æŒ¯ã‚Šã€å¯¾è±¡ã®å¸­ã¨åˆè¨ˆå€¤ã¨ãƒ€ã‚¤ã‚¹ãã‚Œãã‚Œã®å€¤ã‚’è¿”ã™ã€‚ç´”ç²‹ãªæ‰‹ç¶šãã®å…±é€šåŒ–"""
        d1, d2 = Dice.roll()
        total = d1 + d2
        target = Dice.get_target_player_by_total(roller_seat, total)
        return target, total, d1, d2

    # DiceResult = namedtuple("DiceResult", "target_seat d1 d2 total")

    # def roll_for_seat(roller_seat) -> DiceResult:
    #     d1, d2 = Dice.roll()
    #     total = d1 + d2
    #     target_seat = Dice.target_seat_from_total(roller_seat, total)
    #     return DiceResult(target_seat, d1, d2, total)

    def roll_for_seat(roller_seat) -> DiceResult:
        d1, d2 = Dice.roll()
        total = d1 + d2
        target_seat = Dice.target_seat_from_total(roller_seat, total)
        return DiceResult(target_seat=target_seat, d1=d1, d2=d2, total=total)

# ===============================
# ä»®æ±æ±ºã‚ã€ä»®è¦ªæ±ºã‚ã€è¦ªæ±ºã‚ã€å ´é¢¨å‰²ã‚Šå½“ã¦ã‚’è¡Œã†
#     â†’ç¥ã‚¯ãƒ©ã‚¹è‡­ã€‚åˆ†å‰²ã‚’è¦æ¤œè¨
#     â†’å°‘ãªãã¨ã‚‚åãŒä½“ã‚’è¡¨ã—ã¦ã„ãªã„ã€‚è¦æ”¹åã‹ã¨ï¼ˆRoundSetupServiceãªã©ï¼‰
#     â†’ãã‚Œã«seat_to_playerã‚’æŠ±ãˆè¾¼ã‚€ã‚ˆã‚Šå¤–éƒ¨ã«åãå‡ºã—ãŸæ–¹ãŒä»–ã®ã‚¯ãƒ©ã‚¹ã®å‚ç…§ãŒæ¥½ã ã£ãŸã‚Šæ„å‘³çš„ã«è‡ªç„¶ã§ã¯
#     â€»ã“ã®ã‚¯ãƒ©ã‚¹ã ã‘ãƒ†ã‚¹ãƒˆçš„ã«ã‚³ãƒ¡ãƒ³ãƒˆã‚’ã‹ãªã‚Šæ›¸ã„ã¦ã¿ã‚‹
# ===============================
class SeatingManager:
    def __init__(self, players):
        self.players = players
        self.seat_to_player = {}  # å…ƒseat_assignment ä»–æ¡ˆseatingã€seated_players

    # é¢¨ç‰Œã‚’ç”¨æ„
    wind_tiles = ["æ±", "å—", "è¥¿", "åŒ—"]

    # å¸­ã‹ã‚‰ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å¾—ã‚‹
    def player_at(self, seat):
        return self.seat_to_player[seat]

    # ä»®æ±ã®æ±ºå®š
    def decide_kariton(self) -> KaritonDecisionEvent:
        # æ··ãœãŸé¢¨ç‰Œã‚’å„äººãŒå–ã‚‹
        mixer = random.choice(self.players)        # é¢¨ç‰Œã‚’æ··ãœã‚‹äººã‚’ä¹±æ•°ã§é¸å®š
        drawn = random.sample(self.wind_tiles, 4)  # é¢¨ç‰Œé›†åˆã‚’ä¹±æ•°ã§æ··ãœã‚‹
        for p, w in zip(self.players, drawn):      # ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«æ··ãœæ¸ˆã¿é¢¨ç‰Œé›†åˆã‚’zipã§å‰²ã‚Šå½“ã¦
            p.initial_wind = w                     # ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®åˆæœŸé¢¨é…ç½®ã«é¢¨ç‰Œã‚’å‰²ã‚Šå½“ã¦ã‚‹éƒ¨åˆ†

        # ä»®æ±ã¨ä»®æ±ã®å¸­ãŒç¢ºå®š
        kariton_player = next(p for p in self.players if p.initial_wind == "æ±")  # ä»®æ±ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å¾—ã‚‹
        kariton_player.seat = random.choice(["A", "B", "C", "D"])                # ä»®æ±ã®åº§å¸­ã‚’ä¹±æ•°æ±ºå®š
        kariton_player.is_kariton = True                                         # ä»®æ±ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹

        # å„äººãŒå–å¾—é¢¨ç‰Œã«åŸºã¥ã„ã¦åº§å¸­ã«åº§ã‚‹
        self.seat_to_player[kariton_player.seat] = kariton_player        # å¸­ã‹ã‚‰äººè¾æ›¸ã«ä»®æ±ã¨ãã®å¸­ã‚’ç™»éŒ²
        seat = kariton_player.seat                                      # åŸºæº–ã¨ãªã‚‹ä»®æ±ã®å¸­ã‚’seatã«è¨­å®š
        for wind in ["å—", "è¥¿", "åŒ—"]:                                   # wind in å—è¥¿åŒ—é †ã«forå‡¦ç†ã™ã‚‹
            seat = TableOrder.next_counter_clockwise(seat)               # seatã®åæ™‚è¨ˆå›ã‚Šã§æ¬¡ã®å¸­ã‚’seatã«
            p = next(p for p in self.players if p.initial_wind == wind)  # åˆæœŸé¢¨ãŒç¾åœ¨ã®windã®äººã‚’èµ°æŸ»æ¤œç´¢
            p.seat = seat                                                # ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¸­ã«seatã‚’ã‚»ãƒƒãƒˆ
            self.seat_to_player[seat] = p                                # å¸­ã‹ã‚‰äººè¾æ›¸[å¸­]ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ç™»éŒ²

        # return mixer
        return KaritonDecisionEvent(
            kariton_player=kariton_player,
            mixer=mixer
        )

    # ä»®è¦ªæ±ºå®šã¨è¦ªæ±ºå®š
    def decide_parent(self) -> ParentDecisionEvent:
        # ä»®è¦ªæ±ºå®šéƒ¨
        kariton_seat = next(s for s, p in self.seat_to_player.items() if p.is_kariton)  # ä»®æ±ã®å¸­ã‚’å¾—ã‚‹
        temp_parent_seat, _, d1, d2 = Dice.roll_and_get_target(kariton_seat)            # ä»®è¦ªæ±ºè³½,ä»®è¦ªå¸­å¾—
        temp_parent = self.seat_to_player[temp_parent_seat]                             # ä»®è¦ª=è¾æ›¸[ä»®è¦ªå¸­]

        # è¦ªæ±ºå®šéƒ¨
        parent_seat, _, rd1, rd2 = Dice.roll_and_get_target(temp_parent.seat)  # è¦ªæ±ºè³½æŒ¯ã‚Šã€è¦ªå¸­å¾—ã‚‹
        parent = self.seat_to_player[parent_seat]                              # è¦ªï¼å¸­â†’äººè¾æ›¸[è¦ªå¸­]
        parent.is_parent = True                                                # è¦ªã®è¦ªãƒ•ãƒ©ã‚°ã‚’ã‚ªãƒ³

        self.assign_winds(parent.seat)

        # ä»®è¦ªã€è¦ªã€ä»®è¦ªæ±ºå®šæ™‚ã®å‡ºç›®2å€‹ã€è¦ªæ±ºå®šæ™‚ã®å‡ºç›®2å€‹ã‚’è¿”ã™
        return ParentDecisionEvent(
            temp_parent=temp_parent,
            parent=parent,
            temp_parent_decision_dice=(d1, d2),
            parent_decision_dice=(rd1, rd2),
        )

    # å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å ´é¢¨ã‚’å‰²ã‚Šå½“ã¦ã‚‹
    def assign_winds(self, parent_seat):
        parent = self.seat_to_player[parent_seat]                    # è¦ª=å¸­â†’äººè¾æ›¸[è¦ªå¸­]
        parent.wind = "æ±"                                           # è¦ªã«æ±ã®å ´é¢¨ã‚’å‰²ã‚Šå½“ã¦
        idx = TableOrder.counter_clockwise_order.index(parent_seat)  # ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«è¦ªå¸­ã‚’è¨­å®š
        for wind in ["å—", "è¥¿", "åŒ—"]:                               # wind in å—è¥¿åŒ—ã§for
            idx = (idx + 1) % 4                                      # idxã‚’1é€²ã‚â†“ãã®äººã®é¢¨ã‚’â†‘ã«.
            self.seat_to_player[TableOrder.counter_clockwise_order[idx]].wind = wind

    # ãƒ€ã‚¤ã‚¹ã§åº§å¸­ã‚’å¾—ã‚‹ã®ã§ã¯ç„¡ãã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å¾—ã‚‹ãƒ©ãƒƒãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰
    def target_player_by_dice(self, roller_seat, d1, d2):
        target_seat = Dice.target_seat_from_total(roller_seat, d1 + d2)
        return self.player_at(target_seat)

# ===============================
# å“ä¸Šã€‚å£ç‰Œã‚„ã‚‰ãŒç½®ã‹ã‚Œã‚‹ç‰©ç†å ´ã€‚
#     WallRIng.WallåŠã³Cursorã‚„Wanpaiã€Riversã€MeldAreaç­‰ã‚’ç½®ãæ„Ÿã˜ã‹
# ===============================
class MahjongTable:
    def __init__(self, seat_to_player: dict[str, Player], dice: Dice):
        self.seat_to_player = seat_to_player

        self.walls: list[Wall] = []
        self.wall_ring: WallRing | None = None

        self.seat_to_wall: dict[str, Wall] = {}
        self.wall_to_seat: dict[Wall, str] = {}

        self.cursor: WallCursor | None = None
        self.wanpai: Wanpai | None = None

        self.dice = dice

        self.wall_positions = TableOrder.sides  # å£ç‰Œã®ç‰©ç†å­˜åœ¨ä½ç½® â€Aâ€,â€Bâ€,â€Câ€,â€Dâ€
        self.wind_positions = []

        self.events: list = []

    # æ´—ç‰Œ
    def shipai(self):
        tile_list = [t.strip() for t in tiles.split(",")]
        random.shuffle(tile_list)
        self._shuffled_tiles = tile_list
        self.events.append(ShipaiEvent(tile_list.copy()))

    # ç Œç‰Œ
    def chipai(self):
        wall_in_positions = self.wall_positions.copy()
        random.shuffle(wall_in_positions)

        walls = []
        for _ in range(4):
            columns = []
            for _ in range(17):
                columns.append([
                    self._shuffled_tiles.pop(0),
                    self._shuffled_tiles.pop(0)
                ])
            walls.append(Wall(columns))

        self.walls = walls
        self.wall_ring = WallRing(walls)

        # åº§å¸­é †ã§å¯¾å¿œä»˜ã‘ã€€â†’ ã€€å£ç‰Œã®ç‰©ç†å­˜åœ¨ä½ç½®ã‚’ã¾ã ä½¿ç”¨ã—ã¦ã„ãªã„
        for seat, wall in zip(TableOrder.clockwise_order, walls):
            self.seat_to_wall[seat] = wall
            self.wall_to_seat[wall] = seat

        for seat, player in self.seat_to_player.items():
            self.events.append(
                ChipaiEvent(player=player.name,
                            wall_columns=self.seat_to_wall[seat].column_count())
            )

    # é–‹é–€
    def kaimen(self, parent_seat: str):
        dice_result = Dice.roll_for_seat(parent_seat)
        target_wall = self.seat_to_wall[dice_result.target_seat]

        start_col = target_wall.column_count() - dice_result.total - 1
        self.cursor = WallCursor(self.wall_ring, target_wall, start_col)

        self.wanpai = Wanpai(target_wall.columns[-dice_result.total:])

        self.events.append(
            KaimenEvent(
                parent=self.seat_to_player[parent_seat].name,
                target=self.seat_to_player[dice_result.target_seat].name,
                total=dice_result.total,
                d1=dice_result.d1,
                d2=dice_result.d2
            )
        )

    # é…ç‰Œï¼ˆãƒãƒ§ãƒ³ãƒãƒ§ãƒ³å«ã‚€ï¼‰
    def haipai(self, parent_seat: str):
        order = []
        seat = parent_seat
        for _ in range(4):
            order.append(self.seat_to_player[seat])
            seat = TableOrder.next_counter_clockwise(seat)

        # 3å‘¨ Ã— 4æš
        for _ in range(3):
            for p in order:
                u, l = self.cursor.take_pair()
                p.hand_tiles.add(u)
                p.hand_tiles.add(l)

        # ãƒãƒ§ãƒ³ãƒãƒ§ãƒ³
        parent = order[0]
        u1, u2 = self.cursor.take_chonchon()
        parent.hand_tiles.add(u1)
        parent.hand_tiles.add(u2)

        # å­
        order[1].hand_tiles.add(self.cursor.take_single(upper=False))
        order[2].hand_tiles.add(self.cursor.take_single(upper=True))
        order[3].hand_tiles.add(self.cursor.take_single(upper=False))

        for p in order:
            self.events.append(
                HaipaiEvent(player=p.name,
                            tiles=p.hand_tiles.tiles.copy())
            )

# ===============================
# ä½¿ç”¨éº»é›€ç‰Œã®å®šç¾©ï¼ˆåŸºæœ¬çš„ã«å¤‰æ›´ç¦æ­¢ï¼šå‰æã‚„æ–¹é‡ãŒãƒ–ãƒ¬ã‚‹ã®ã§ï¼‰
# ===============================
tiles = "ğŸ€‡,ğŸ€‡,ğŸ€‡,ğŸ€‡,ğŸ€ˆ,ğŸ€ˆ,ğŸ€ˆ,ğŸ€ˆ,ğŸ€‰,ğŸ€‰,ğŸ€‰,ğŸ€‰,ğŸ€Š,ğŸ€Š,ğŸ€Š,ğŸ€Š,ğŸ€‹èµ¤,ğŸ€‹,ğŸ€‹,ğŸ€‹,ğŸ€Œ,ğŸ€Œ,ğŸ€Œ,ğŸ€Œ,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€™,ğŸ€™,ğŸ€™,ğŸ€™,ğŸ€š,ğŸ€š,ğŸ€š,ğŸ€š,ğŸ€›,ğŸ€›,ğŸ€›,ğŸ€›,ğŸ€œ,ğŸ€œ,ğŸ€œ,ğŸ€œ,ğŸ€èµ¤,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€Ÿ,ğŸ€Ÿ,ğŸ€Ÿ,ğŸ€Ÿ,ğŸ€ ,ğŸ€ ,ğŸ€ ,ğŸ€ ,ğŸ€¡,ğŸ€¡,ğŸ€¡,ğŸ€¡,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€‘,ğŸ€‘,ğŸ€‘,ğŸ€‘,ğŸ€’,ğŸ€’,ğŸ€’,ğŸ€’,ğŸ€“,ğŸ€“,ğŸ€“,ğŸ€“,ğŸ€”èµ¤,ğŸ€”,ğŸ€”,ğŸ€”,ğŸ€•,ğŸ€•,ğŸ€•,ğŸ€•,ğŸ€–,ğŸ€–,ğŸ€–,ğŸ€–,ğŸ€—,ğŸ€—,ğŸ€—,ğŸ€—,ğŸ€˜,ğŸ€˜,ğŸ€˜,ğŸ€˜,ğŸ€€,ğŸ€€,ğŸ€€,ğŸ€€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€‚,ğŸ€‚,ğŸ€‚,ğŸ€‚,ğŸ€ƒ,ğŸ€ƒ,ğŸ€ƒ,ğŸ€ƒ,ğŸ€†,ğŸ€†,ğŸ€†,ğŸ€†,ğŸ€…,ğŸ€…,ğŸ€…,ğŸ€…,ğŸ€„,ğŸ€„,ğŸ€„,ğŸ€„"

meaning = {
    "ğŸ€‡": "1m", "ğŸ€ˆ": "2m", "ğŸ€‰": "3m", "ğŸ€Š": "4m",
    "ğŸ€‹": "5m", "ğŸ€Œ": "6m", "ğŸ€": "7m", "ğŸ€": "8m", "ğŸ€": "9m",
    "ğŸ€‹èµ¤": "5mRed",

    "ğŸ€™": "1p", "ğŸ€š": "2p", "ğŸ€›": "3p", "ğŸ€œ": "4p",
    "ğŸ€": "5p", "ğŸ€": "6p", "ğŸ€Ÿ": "7p", "ğŸ€ ": "8p", "ğŸ€¡": "9p",
    "ğŸ€èµ¤": "5pRed",

    "ğŸ€": "1s", "ğŸ€‘": "2s", "ğŸ€’": "3s", "ğŸ€“": "4s",
    "ğŸ€”": "5s", "ğŸ€•": "6s", "ğŸ€–": "7s", "ğŸ€—": "8s", "ğŸ€˜": "9s",
    "ğŸ€”èµ¤": "5sRed",

    "ğŸ€€": "ton", "ğŸ€": "nan", "ğŸ€‚": "sha", "ğŸ€ƒ": "pei",
    "ğŸ€†": "haku", "ğŸ€…": "hatsu", "ğŸ€„": "chun"
}

# ===============================
# å£ç‰Œã®æ§‹é€ 
# ===============================
class Wall:
    def __init__(self, columns: list[list[str]]):
        self.columns = columns  # [[upper, lower], ...]

    def take_pair(self, col: int):
        upper, lower = self.columns[col]
        self.columns[col] = [None, None]
        return upper, lower

    def take_single(self, col: int, upper: bool):
        idx = 0 if upper else 1
        tile = self.columns[col][idx]
        self.columns[col][idx] = None
        return tile

    def column_count(self):
        return len(self.columns)

# ===============================
# å£ç‰Œ4ã¤ã‚’è¼ªã¨ã—ã¦è¦‹ã‚‹ã€‚
#     ã‚«ãƒ¼ã‚½ãƒ«ã¯æŒãŸãšã€æšæ•°ã‚’ç®¡ç†ã›ãšã€è²¬å‹™ã¯ã€Œæ¬¡ã®å£ã¯ã©ã‚Œã‹ã‚’æ•™ãˆã‚‹ã€
# ===============================
class WallRing:
    def __init__(self, ordered_walls: list[Wall]):
        assert len(ordered_walls) == 4
        self.walls = ordered_walls

    def next_wall(self, wall: Wall) -> Wall:
        idx = self.walls.index(wall)
        return self.walls[(idx + 1) % 4]

# ===============================
# å£ç‰Œã‚«ãƒ¼ã‚½ãƒ«
# ===============================
class WallCursor:
    def __init__(self, ring: WallRing, start_wall: Wall, start_col: int):
        self.ring = ring
        self.wall = start_wall
        self.col = start_col  # å³ç«¯åŸºæº–

    def _advance_wall(self):
        self.wall = self.ring.next_wall(self.wall)
        self.col = self.wall.column_count() - 1

    def take_pair(self):
        if self.col < 0:
            self._advance_wall()

        tiles = self.wall.take_pair(self.col)
        self.col -= 1
        return tiles

    def take_single(self, upper: bool):
        if self.col < 0:
            self._advance_wall()

        tile = self.wall.take_single(self.col, upper)

        # ä¸‹æ®µã‚’å–ã£ãŸã¨ãã ã‘åˆ—ã‚’æ¶ˆè²»
        if not upper:
            self.col -= 1

        return tile

    def take_chonchon(self):
        first = self.take_single(upper=True)   # self.col -= 1ã¯åˆ—ã‚’1ã¤æ¶ˆè²»ï¼ˆï¼ä¸‹æ®µã‚’ç©ºæ¶ˆè²»ï¼‰
        self.col -= 1                          # ã“ã‚Œã§ã¯çµ¶å¯¾ãƒ€ãƒ¡ãªã®ã§ã‚‚ã†æ³¥è‡­ãã‚„ã£ãŸæ–¹ãŒã„ã„ã€‚
        second = self.take_single(upper=True)  # ä¸€å¿œã€4å‘¨ç›®ã«è¦ªå­å­å­ã¨ä¸€æšãšã¤å–ã£ã¦è¦ªã ã‘5å‘¨ç›®ã‚’å–ã‚Œã°çµæœã¯ãƒãƒ§ãƒ³ãƒãƒ§ãƒ³ã¨åŒã˜ã§ã¯ã‚ã‚‹ã€‚
        return first, second                   # ãŸã ã€ãŸã¨ãˆçµæœãŒåŒã˜ã§ã‚‚ã“ã‚Œã¯ãƒˆã‚³ãƒˆãƒ³ãƒªã‚¢ãƒ«éº»é›€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ç›®æŒ‡ã™ã®ã§ã€éç¨‹ã‚’ã‚‚å†ç¾ã—ãŸã„ã€‚

# ===============================
# å£ç‰Œã®ç®¡ç†
# ===============================
class WallManager:
    def __init__(self, seat_to_player, dice):
        self.seat_to_player = seat_to_player
        self.dice = dice

    # æ´—ç‰Œ = ç‰Œã‚’æ··ãœã‚‹
    def shipai(self):
        tile_list = [t.strip() for t in tiles.split(",")]
        random.shuffle(tile_list)
        return tile_list

    # ç Œç‰Œ = å£ç‰Œã‚’ç©ã‚€
    def chipai(self, tile_list):
        for p in self.seat_to_player.values():
            wall = Wall()
            for _ in range(17):
                upper, lower = tile_list.pop(0), tile_list.pop(0)
                wall.add_column(upper, lower)
            p.wall = wall

    # é–‹é–€ ï¼ åˆ‡ã‚Šå±±ã®ä½ç½®æ±ºå®š    é ã„å°†æ¥ã€å‰²ã‚Œç›®ãƒ«ãƒ¼ãƒ«ã‚’ONã«å‡ºæ¥ã‚‹ãªã‚‰ã°ã€é–‹é–€æ‹…å½“è€…==å‰²ã‚Œç›®ã ã‹ã‚‰ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¯å¿…è¦ã€‚ãã†ã§ãªãã¨ã‚‚å°‘ãªãã¨ã‚‚é–‹é–€å¯¾è±¡å£ç‰Œã¯ç‰¹å®šã—ãªãã¦ã¯ãªã‚‰ãªã„ã€‚
    def kaimen(self, parent):
        target_side, total, d1, d2 = self.dice.roll_and_get_target(parent.seat)
        target = self.seat_to_player[target_side]
        return target, total, d1, d2

# ===============================
# æ‰‹ç‰Œ
# ===============================
class HandTiles:
    def __init__(self):
        self.tiles = []

    def add(self, tile):
        self.tiles.append(tile)

    def __len__(self):
        return len(self.tiles)

    def __repr__(self):
        return " ".join(self.tiles)

# ===============================
# é…ç‰Œç®¡ç†
# ===============================
class HaipaiManager:
    def __init__(self, seat_to_player, parent, start_col):
        self.seat_to_player = seat_to_player
        self.parent = parent
        self.cursor = WallCursor(seat_to_player, parent, start_col)

    def players_ccw(self):
        order = []
        side = self.parent.seat
        for _ in range(4):
            order.append(self.seat_to_player[side])
            side = TableOrder.next_counter_clockwise(side)
        return order

    def deal_four_tiles(self):
        for p in self.players_ccw():
            for _ in range(2):
                u, l = self.cursor.take_pair()
                p.hand.add(u)
                p.hand.add(l)

    def take_chonchon(self):
        players = self.players_ccw()
        parent = players[0]

        # æ—§ãƒãƒ§ãƒ³ãƒãƒ§ãƒ³ã®åæ®‹ã€€æ¬¡ä»¥é™æ¶ˆã™
        # t1 = self.cursor.take_single(upper=True)
        # self.cursor.skip_column()
        # t2 = self.cursor.take_single(upper=True)

        parent.hand.add(t1)
        parent.hand.add(t2)

    def deal_initial(self):
        # 3å‘¨ Ã— 4æš
        for _ in range(3):
            self.deal_four_tiles()

        # ç‰¹æ®Šä¸€å‘¨
        players = self.players_ccw()

        # è¦ªï¼šãƒãƒ§ãƒ³ãƒãƒ§ãƒ³
        self.take_chonchon()

        # å­
        players[1].hand.add(self.cursor.take_single(upper=False))
        players[2].hand.add(self.cursor.take_single(upper=True))
        players[3].hand.add(self.cursor.take_single(upper=False))

# ===============================
# ãƒãƒ§ãƒ³ãƒãƒ§ãƒ³å®Ÿè£…ã‚¬ãƒ¯ã‚’ãƒ†ã‚¹ãƒˆã§ä½œã‚‹ç‚ºã®ã‚¯ãƒ©ã‚¹
# ===============================
class DealPhase:
    def execute(self, mahjong_table):
        self._deal_normal_rounds(mahjong_table, times=3)
        self._deal_chonchon_round(mahjong_table)

    def _deal_chonchon_round(self, table):
        parent = table.parent
        cursor = table.wall_cursor

        # è¦ªã ã‘ç‰¹æ®Š
        parent.hand.add(cursor.take_chonchon_first())
        parent.hand.add(cursor.take_chonchon_second())

        # æ®‹ã‚Šã¯é€šå¸¸1æšãšã¤
        for p in mahjong_table.players_ccw_from(parent):
            p.hand.add(cursor.take_next())

# ===============================
# ç‹ç‰Œ
# ===============================
class Wanpai:
    def __init__(self, wall_columns):
        self.columns = wall_columns[:7]

    def dora_indicator(self):
        return self.columns[2][0]

# ===============================
# ãƒ‰ãƒ©åˆ¤å®š
# ===============================
# çµµæ–‡å­—ã«ä¾ã‚‹ãƒ‰ãƒ©åˆ¤å®š
class DoraIndicator:
    @staticmethod
    def next(tile):
        if tile in "ğŸ€‡ğŸ€ˆğŸ€‰ğŸ€ŠğŸ€‹ğŸ€ŒğŸ€ğŸ€ğŸ€":
            nums = ["ğŸ€‡", "ğŸ€ˆ", "ğŸ€‰", "ğŸ€Š", "ğŸ€‹", "ğŸ€Œ", "ğŸ€", "ğŸ€", "ğŸ€"]
            return nums[(nums.index(tile) + 1) % 9]

        if tile in "ğŸ€™ğŸ€šğŸ€›ğŸ€œğŸ€ğŸ€ğŸ€ŸğŸ€ ğŸ€¡":
            nums = ["ğŸ€™", "ğŸ€š", "ğŸ€›", "ğŸ€œ", "ğŸ€", "ğŸ€", "ğŸ€Ÿ", "ğŸ€ ", "ğŸ€¡"]
            return nums[(nums.index(tile) + 1) % 9]

        if tile in "ğŸ€ğŸ€‘ğŸ€’ğŸ€“ğŸ€”ğŸ€•ğŸ€–ğŸ€—ğŸ€˜":
            nums = ["ğŸ€", "ğŸ€‘", "ğŸ€’", "ğŸ€“", "ğŸ€”", "ğŸ€•", "ğŸ€–", "ğŸ€—", "ğŸ€˜"]
            return nums[(nums.index(tile) + 1) % 9]

        winds = ["ğŸ€€", "ğŸ€", "ğŸ€‚", "ğŸ€ƒ"]
        if tile in winds:
            return winds[(winds.index(tile) + 1) % 4]

        dragons = ["ğŸ€†", "ğŸ€…", "ğŸ€„"]
        return dragons[(dragons.index(tile) + 1) % 3]


# ===============================
# ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¯ãƒ©ã‚¹
# ===============================
kana_chars = list("ã‚¢ã‚¤ã‚¦ã‚¨ã‚ªã‚«ã‚­ã‚¯ã‚±ã‚³ã‚µã‚·ã‚¹ã‚»ã‚½ã‚¿ãƒãƒ„ãƒ†ãƒˆãƒŠãƒ‹ãƒŒãƒãƒãƒãƒ’ãƒ•ãƒ˜ãƒ›ãƒãƒŸãƒ ãƒ¡ãƒ¢ãƒ¤ãƒ¦ãƒ¨ãƒ©ãƒªãƒ«ãƒ¬ãƒ­ãƒ¯ãƒ²ãƒ³ã‚¬ã‚®ã‚°ã‚²ã‚´ã‚¶ã‚¸ã‚ºã‚¼ã‚¾ãƒ€ãƒ‚ãƒ…ãƒ‡ãƒ‰ãƒãƒ“ãƒ–ãƒ™ãƒœãƒ‘ãƒ”ãƒ—ãƒšãƒ")


class Player:
    def __init__(self, name, type_="CPU"):
        self.name = name
        self.type = type_
        self.initial_wind = None  # ä»®ã§å¼•ã„ãŸé¢¨ç‰Œ
        self.seat = None  # A/B/C/D å¸­ï¼ˆå ´é¢¨ã¨ã¯åˆ¥ï¼‰
        self.wind = None  # æ±å—è¥¿åŒ—ï¼ˆæœ€çµ‚çš„ãªå®¶ï¼‰
        self.is_kariton = False
        self.is_parent = False
        self.hand_tiles = HandTiles()

    def __repr__(self):
        return f"{self.name}({self.type}, seat={self.seat}, wind={self.wind})"

    @staticmethod
    def generate_player_name():
        return "".join(random.choices(kana_chars, k=random.randint(2, 4)))


# ===============================
# ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼
# ===============================
class PlayerFactory:
    @staticmethod
    def create_players():
        players = [Player(Player.generate_player_name()) for _ in range(3)]
        players.append(Player("ã‚ãªãŸ", type_="Human"))
        random.shuffle(players)
        return players


# ===============================
# ä¸€å±€å˜ä½ã®ç®¡ç†ã€‚çŠ¶æ…‹ã‚’é€²ã‚ã€Eventã‚’ç”Ÿæˆï¼ˆUIã«è§¦ã‚Œãªã„ï¼‰
# ===============================
class Round:
    def __init__(self, players, dice):
        self.players = players
        self.dice = dice
        self.seating = SeatingManager(players)

    def start(self) -> list:
        events = []

        kariton_event = self.seating.decide_kariton()
        events.append(kariton_event)

        parent_event = self.seating.decide_parent()
        events.append(parent_event)

        mahjong_table = MahjongTable(self.seating.seat_to_player)

        mahjong_table.shipai()
        mahjong_table.chipai()
        mahjong_table.kaimen(parent_event.parent.seat)
        mahjong_table.haipai(parent_event.parent.seat)
        events = mahjong_table.events

        indicator = table.wanpai.dora_indicator()
        events.append(
            DoraRevealedEvent(
                indicator=indicator,
                dora=DoraIndicator.next(indicator)
            )
        )

        return events


# ===============================
# å¸ä»¤å¡”ã€€class Application ã¨ã‚‚è¨€ãˆã‚‹
# ===============================
class Game:
    def __init__(self, logger, dice):
        self.logger = logger
        self.dice = dice
        self.players = PlayerFactory.create_players()
        self.event_mgr = EventManager()
        self.log_manager = LogManager(logger)

    def run(self):
        scene = MatchScene(self)
        scene.enter()


# ===============================
# ãƒ¡ã‚¤ãƒ³å‡¦ç†
# ===============================
class Scene:
    def enter(self):
        pass

    def update(self):
        pass

    def exit(self):
        pass


class MatchScene(Scene):
    def __init__(self, game):
        self.game = game

    def enter(self):
        round = Round(self.game.players, self.game.dice)
        events = round.start()
        for e in events:
            self.game.event_mgr.push(e)
            self.game.log_manager.consume(e)
            self.game.log_manager.show_all_walls(round.seating.seat_to_player)


# ===============================
# è¡¨ç¤ºã®èª¿æ•´ã€€UIï¼ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å±¤    ã‚‚ã†ãƒ¬ã‚¬ã‚·ãƒ¼ã™ãã¦ã€ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã®ç‚ºã«ä¸€å›å£Šã™å¿…è¦ãŒã‚ã‚‹æ°—ãŒã™ã‚‹
# ===============================
class LogManager:
    def __init__(self, logger):
        self.logger = logger

    def consume(self, event):
        if isinstance(event, KaritonDecisionEvent):
            self.logger.log(
                f"ä»®æ±: {event.kariton_player.name} / æ··ãœãŸäºº: {event.mixer.name}"
            )
        elif isinstance(event, ParentDecisionEvent):
            self.logger.log(
                f"ä»®è¦ª: {event.temp_parent.name} â†’ è¦ª: {event.parent.name}"
            )
        elif isinstance(event, ShipaiEvent):
            self.logger.log(
                "æ´—ç‰Œå®Œäº†"
            )
        elif isinstance(event, ChipaiEvent):
            self.logger.log(
                f"{event.player} ã®å£ç‰Œï¼š{event.wall_columns} åˆ—"
            )
        elif isinstance(event, KaimenEvent):
            self.logger.log(
                f"é–‹é–€ï¼š{event.target}ï¼ˆå‡ºç›® {event.d1}+{event.d2}={event.total}ï¼‰"
            )
        elif isinstance(event, HaipaiEvent):
            self.logger.log(
                f"{event.player} æ‰‹ç‰Œ: {' '.join(event.tiles)}"
            )
        elif isinstance(event, DoraRevealedEvent):
            self.logger.log(
                f"ãƒ‰ãƒ©è¡¨ç¤ºç‰Œ: {event.indicator} â†’ ãƒ‰ãƒ© {event.dora}"
            )

    def show_all_walls(self, seat_to_player):
        self.logger.log("\nâ”€â”€â”€ å…¨å“¡ã®å£ç‰Œ â”€â”€â”€")
        for wind in TableOrder.wind_order:
            for p in seat_to_player.values():
                if p.wind == wind:
                    self.logger.log(f"ã€{p.wind}å®¶ {p.name}ã€‘")
                    self.logger.log("ä¸Šæ®µï¼š" + " ".join(p.wall.upper_row()))
                    self.logger.log("ä¸‹æ®µï¼š" + " ".join(p.wall.lower_row()))

    def log_title(self, title):
        self.logger.log(f"\nâ”€â”€â”€ {title} â”€â”€â”€")

    def log_title_and_contents(self, title, contents):
        self.log_title(title)
        self.logger.log(f"\n" + contents)

    # ã€Œå¼•ã„ãŸé¢¨ç‰Œã€ã‚’é¢¨ã®ä¸¦ã³é †ã«ã‚½ãƒ¼ãƒˆè¡¨ç¤º
    def show_drawn_winds(self, players):
        self.log_title("å„ã€…ãŒå¼•ã„ãŸé¢¨ç‰Œ")
        sorted_players = sorted(
            players, key=lambda p: TableOrder.wind_order.index(p.initial_wind))
        self.logger.log(", ".join(f"{p.name}:{p.initial_wind}" for p in sorted_players))

    # å¸­è¡¨ç¤ºãƒ»å ´é¢¨è¡¨ç¤ºã‚’é¢¨ã®ä¸¦ã³é †ã«ã‚½ãƒ¼ãƒˆè¡¨ç¤º
    def show_seating_by_wind(self, seat_to_player):
        sorted_items = sorted(
            kariton_order.items(),
            key=lambda item: TableOrder.wind_order.index(item[1].wind)
        )
        for side, player in sorted_items:
            self.logger.log(f"{side} {player.name} ({player.wind})")

    # å¸­è¡¨ç¤ºãƒ»å ´é¢¨è¡¨ç¤ºã‚’åˆæœŸé¢¨ã®ä¸¦ã³é †ã«ã‚½ãƒ¼ãƒˆè¡¨ç¤º
    def show_seating_by_initial_wind(self, seat_to_player):
        sorted_items = sorted(
            kariton_order.items(),
            key=lambda item: TableOrder.wind_order.index(item[1].initial_wind)
        )
        for side, player in sorted_items:
            self.logger.log(f"{side} {player.name} ({player.initial_wind})")

    # ã‚µã‚¤ã‚³ãƒ­æ¼”å‡º
    def show_dice(self, roller_name, die1, die2):
        self.logger.log(f"â”€â”€â”€ {roller_name} ãŒã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã‚Šã¾ã—ãŸâ€¦â€¦")
        self.logger.log(f" {die1}ã€{die2} ï¼ å‡ºç›®åˆè¨ˆ {die1 + die2} â”€â”€â”€")

    # æ´—ç‰Œçµæœè¡¨ç¤º
    def show_shipai_result(self, tile_list):
        self.log_title("æ´—ç‰Œ")
        self.logger.log(f"ç¾åœ¨ã®ç‰Œä¸¦ã³: {', '.join(tile_list)}")
        self.logger.log(
            "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        )

    # å£ç‰Œè¡¨ç¤º
    def show_wall(self, player):
        self.logger.log(f"ã€{player.wind}å®¶ã€€{player.name}ï¼ˆ{player.seat}å¸­ï¼‰ã®å£ç‰Œã€‘")
        self.logger.log("ä¸Šæ®µï¼š" + ", ".join(player.wall.upper_row()))
        self.logger.log("ä¸‹æ®µï¼š" + ", ".join(player.wall.lower_row()))
        self.logger.log(
            "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        )

    # å…¨å“¡åˆ†ã®å£ç‰Œã‚’é¢¨ã®ä¸¦ã³é †ã§è¡¨ç¤º
    # def show_all_walls(self, seat_to_player):
    #     for wind in TableOrder.wind_order:
    #         for side, player in kariton_order.items():
    #             if player.wind == wind:
    #                 self.show_wall(player)

    # é–‹é–€è¡¨ç¤º
    def show_kaimen_wall(self, player, total):
        self.log_title("é–‹é–€")
        idx = len(player.wall.columns) - total

        upper = player.wall.upper_row()
        lower = player.wall.lower_row()

        upper.insert(idx, " é–‹é–€ä½ç½® ")
        lower.insert(idx, " é–‹é–€ä½ç½® ")

        self.logger.log(f"ã€{player.wind}å®¶ã€€{player.name}ï¼ˆ{player.seat}å¸­ï¼‰ã®å£ç‰Œã€‘")
        self.logger.log("ä¸Šæ®µï¼š" + ", ".join(upper))
        self.logger.log("ä¸‹æ®µï¼š" + ", ".join(lower))

    # ã‚µã‚¤ã‚³ãƒ­æ¼”å‡º2 ç›®çš„ã®ç‚ºã«ã€åå‰ãŒã€ã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã‚Šã€å‡ºç›®äºŒã¤ã¯ã“ã‚Œã§åˆè¨ˆã¯ã“ã‚Œã§ã€çµæœã“ã†ã•
    def log_dice(self, roll_purpose, roller_name, die1, die2, result_message):
        self.logger.log(f"\nâ”€â”€â”€ {roll_purpose} ã®ç‚ºã« {roller_name} ãŒã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã‚Šã¾ã—ãŸâ€¦â€¦")
        self.logger.log(f"{die1}ã€{die2} ï¼ å‡ºç›®åˆè¨ˆ {die1 + die2}")
        self.logger.log(result_message)

# ===============================
# ãƒ¡ã‚¤ãƒ³å‡¦ç†
# ===============================
if __name__ == "__main__":
    Game(logger, Dice()).run()

