# å€‹åˆ¥ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚¯ãƒ©ã‚¹ã€ã‚¤ãƒ™ãƒ³ãƒˆãƒã‚¹ã‚’ãƒãƒƒãƒ•ã‚¡å‹ã«ã€Rendererã®è¿½åŠ ã€
# ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã«Compositeãƒ‘ã‚¿ãƒ¼ãƒ³å°å…¥ã€
# ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã‚¯ãƒ©ã‚¹ã‚’å°å…¥â†’Visitorãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åˆ©ç”¨ã™ã‚‹
# ã‚³ãƒãƒ³ãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å°å…¥â†’ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã¨ã®Visitorãƒ‘ã‚¿ãƒ¼ãƒ³ã¨å™›ã¿åˆã‚ã›ä¸­
# å°†æ¥å°å…¥äºˆå®šã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚„GUIå‘¨ã‚Šã®ã‚¯ãƒ©ã‚¹ã‚’ä¸€éƒ¨å°å…¥
# StateMachineã‚’çŠ¶æ…‹ã«å…¥ã‚‹ã‚‚ã®ã«ã™ã‚‹ã‹çŠ¶æ…‹ã‚’å®Ÿè¡Œã™ã‚‹ã‚‚ã®ã«ã™ã‚‹ã‹
# ã‚ã¨ã€ãƒ“ã‚¸ã‚¿ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ˜ç¤ºçš„ã«å¼·åŒ–ã—ãŸã‚Šã—ãŸ
# ã‚ã¨ã€å„ç¨®æ—§å®Ÿè£…ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã—ãŸã‚Šã—ãŸï¼ˆæ¬¡ã®æ›´æ–°ã§ã¯æ¶ˆã™ã‹ï¼‰

# å¤‰æ›´äºˆå®šï¼š
#     ãƒ»ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã®è¡¨ç¤ºã¯LogEvent(type:Enum, param: dict)ã¨Enumã§è¡Œã†å½¢ã¸
#     ãƒ»å„ç¨®å‘¼ã³å‡ºã—å´ã€å‡¦ç†å±¤ã‚„ãƒ‰ãƒ¡ã‚¤ãƒ³å±¤ã®æ—§ã„ãƒ­ã‚¸ãƒƒã‚¯ã‚„è­˜åˆ¥å­ã‚’ç¾è¡Œå®Ÿè£…ã¸æ›è£…

# Visitor åˆ¤æ–­ãƒ»åˆ†å²ã€€ æœ¬æ¥ã¯æ–¹æ³•ã‚„å‡¦ç†ã‚’æŒã¤ãŒãã‚Œã¯Commandã®receiverã«å§”è­²
# Command å®Ÿè¡Œ         å‡¦ç†ã‚„æ–¹æ³•ã‚’æŒã¤receiverã‚’ä¿æŒã—ãã‚Œã‚’å®Ÿè¡Œã™ã‚‹å½¹ç›®
# Phase   å®Ÿè¡Œé †ã®ç®¡ç† ãã®æ®µéšã«ãŠã„ã¦ãƒ‰ãƒ¡ã‚¤ãƒ³çš„ã«å¿…è¦ãªVisitorã‚’é¸ã¶
# Event   èµ·ããŸäº‹å®Ÿ   

# Phaseã‚„EventHandlerãªã©ã€ãƒ‰ãƒ¡ã‚¤ãƒ³å‡¦ç†ã‚’ã—ãŸã„å ´æ‰€ã«ãŠã„ã¦Visitorã‚’ç”Ÿæˆã—ã€
# player.mode.accept_visitor(visitor)ã§ã‚³ãƒãƒ³ãƒ‰ã‚’ç”Ÿæˆã—å®Ÿè¡Œã™ã‚‹


import sys
import time
import random
import inspect
from abc import ABC, abstractmethod
from typing import Sequence
from typing import Protocol
from dataclasses import dataclass

# -----------------------------------------------
# æç”»ã‚¯ãƒ©ã‚¹ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ãŒã‚¤ãƒ™ãƒ³ãƒˆæ¯ã«è¡¨ç¤ºã—ãŸã„æ–‡è¨€
# -----------------------------------------------

EVENT_MESSAGE = {
    TIMEOUT_DETECTED                : f"watchdog:ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆé˜²æ­¢",
    STATE_MACHINE_NOT_PROGRESSING   : f"StateMachine ãŒé€²è¡Œã—ã¾ã›ã‚“ã§ã—ãŸ",
    FAIL_SAFE_MAX_LOOP_COUNT        : f"Fail-safe:ç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢",
    INPUT_AVAILABILITY              : f"ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å…¥åŠ›ãŒç„¡åŠ¹ã«ãªã£ã¦ã„ã¾ã™",
    NEXT_PHASE_NOT_FOUND_1          : f"æ¬¡ã®ãƒ•ã‚§ãƒ¼ã‚ºã¯ã‚ã‚Šã¾ã›ã‚“1",
    NEXT_PHASE_NOT_FOUND_2          : f"æ¬¡ã®ãƒ•ã‚§ãƒ¼ã‚ºã¯ã‚ã‚Šã¾ã›ã‚“2",

    GAME_START                      : f"ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã—ã¾ã™",
    GAME_END                        : f"ã‚²ãƒ¼ãƒ ã‚’çµ‚äº†ã—ã¾ã™",

    TITLE_SCENE_START               : f"ã“ã“ã¯ãã†ã€ã‚¿ã‚¤ãƒˆãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ç”»é¢",
    TITLE_SCENE_END                 : f"ã‚¿ã‚¤ãƒˆãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ç”»é¢ã‚’çµ‚ãˆã¾ã™ã",

    MATCH_SCENE_START               : f"å¯¾å±€é–‹å§‹ã§ã£ã›",
    MATCH_SCENE_END                 : f"å¯¾å±€çµ‚äº†ã§ã™ã‚",

    RESULT_SCENE_START              : f"è©¦åˆçµæœã§ã™ã‚ˆ",
    RESULT_SCENE_END                : f"è©¦åˆçµæœã•ã‚ˆãªã‚‰",

    WIND_TILE_SHUFFLE_PHASE_START   : f"é¢¨ç‰Œã‚·ãƒ£ãƒƒãƒ•ãƒ«ãƒ•ã‚§ã‚¤ã‚ºãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸ",
    WIND_TILE_SHUFFLED              : f"é¢¨ç‰Œã¯ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã•ã‚Œã¾ã—ãŸ",
    WIND_TILE_SHUFFLE_PHASE_END     : f"é¢¨ç‰Œã‚·ãƒ£ãƒƒãƒ•ãƒ«ãƒ•ã‚§ã‚¤ã‚ºãŒçµ‚äº†ã—ã¾ã—ãŸ",

    WIND_TILE_SELECTION_PHASE_START : f"é¢¨ç‰Œé¸æŠãƒ•ã‚§ã‚¤ã‚ºãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸ",
    WIND_TILE_SELECTION_PHASE_END   : f"é¢¨ç‰Œé¸æŠãƒ•ã‚§ã‚¤ã‚ºãŒçµ‚äº†ã—ã¾ã—ãŸ",
    WIND_TILE_SELECTION_VALID       : f"é¢¨ç‰ŒãŒé¸ã°ã‚Œã¾ã—ãŸ",
    WIND_TILE_SELECTION_INVALID     : f"é¸ã‚“ã é¢¨ç‰Œã¯ç„¡åŠ¹ã§ã—ãŸã€‚ãƒ©ãƒ³ãƒ€ãƒ ã§é¸ã³ã¾ã™",
    WIND_TILE_RANDOM_CHOOSE         : f"é¢¨ç‰Œã‚’ãƒ©ãƒ³ãƒ€ãƒ ã§é¸ã³ã¾ã—ãŸ",
    WIND_TILE_SELECTION_NONE        : f"é¢¨ç‰ŒãŒç„¡ãã¦é¸ã¹ã¾ã›ã‚“"
    
    TILE_DISCARDED                  : f"Player {event.player_id} discarded {event.tile}"
}

# -----------------------------------------------
# ãƒ‡ãƒãƒƒã‚°ç”¨
# -----------------------------------------------

# ã‚°ãƒ­ãƒ¼ãƒãƒ«ã®ãƒ‡ãƒãƒƒã‚°ãƒ•ãƒ©ã‚°
DEBUG = False # True

class Debug:
    print_call_counter = 0
    
    @classmethod
    def print(cls, obj, msg: str = None):
        """ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ obj ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰å‘¼ã°ã‚ŒãŸã¨ãã®ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›"""
        if not DEBUG:
            return

        cls.print_call_counter += 1

        # å‘¼ã³å‡ºã—å…ƒã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å–å¾—
        frame = inspect.currentframe().f_back
        lineno = frame.f_lineno
        method_name = frame.f_code.co_name
        class_name = obj.__class__.__name__ if obj else "Global"

        print(f"debug_print ...    | è¡Œ: {lineno} | ä½•å‡¦: {class_name:<18} ã® {method_name:<12} | {cls.print_call_counter}å›ç›® | è£œè¶³ : {msg}")


# -----------------------------------------------
# æ–‡å­—åˆ—ã‚’è£…é£¾ã™ã‚‹
# -----------------------------------------------

class StringDecotater(Protocol):
    FIXED_LINE = "â”€" * 8    # å›ºå®š8æ–‡å­—ç½«ç·šï¼ˆç½«ç·šã¯å…¨è§’æ–‡å­—ã€å¹…2ï¼‰
    FIXED_SPACE = "ã€€" * 8  # å›ºå®š8æ–‡å­—ã‚¹ãƒšãƒ¼ã‚¹ï¼ˆå…¨è§’ã‚¹ãƒšãƒ¼ã‚¹ã€å¹…2ï¼‰
    LEFT_WIDTH = len(FIXED_LINE) * 2 + len(FIXED_SPACE) * 2   # æœ€åˆã®ç½«ç·šã¨ã‚¹ãƒšãƒ¼ã‚¹ len()ã¯ç´”ç²‹ãªæ–‡å­—æ•°ãªã®ã§å…¨è§’2byte->*2ã™ã‚‹
    RIGHT_WIDTH = len(FIXED_SPACE) * 2 + len(FIXED_LINE) * 2  # æœ€å¾Œã®ã‚¹ãƒšãƒ¼ã‚¹ã¨ç½«ç·š
    STRING_WIDTH = LEFT_WIDTH + RIGHT_WIDTH + 40              # å…¨ä½“å¹…ï¼ˆã“ã“ã«åˆã‚ã›ã¦å†…å®¹ãŒèª¿æ•´ã•ã‚Œã‚‹ï¼‰

    # å…¨è§’æ–‡å­—ã¨åŠè§’æ–‡å­—ã‚’æ‰‹å‹•ã§åŒºåˆ¥ã—ã¦å¹…ã‚’è¨ˆç®—
    @staticmethod
    def calculate_width(msg: str) -> int:
        width = 0
        for char in msg:
            if len(char.encode('utf-8')) > 1:  # 2ãƒã‚¤ãƒˆä»¥ä¸Šãªã‚‰å…¨è§’
                width += 2                     # å…¨è§’æ–‡å­—ã¯å¹…2
            else:  # åŠè§’æ–‡å­—ã¯1
                width += 1
        return width

    @staticmethod
    def _decorate_fixed_print(self, handled_message: str):
        # ä¸­å¤®éƒ¨åˆ†ã®å†…å®¹ã®å¹…ã‚’è¨ˆç®—ï¼ˆå…¨è§’ã¨åŠè§’ã‚’è€ƒæ…®ï¼‰
        central_len = self.calculate_width(handled_message)

        # æ®‹ã‚Šã®ã‚¹ãƒšãƒ¼ã‚¹ã‚’è¨ˆç®—ï¼ˆå³å´ã®å¯å¤‰ã‚¹ãƒšãƒ¼ã‚¹ï¼‰
        total_used_width = self.LEFT_WIDTH + central_len + self.RIGHT_WIDTH
        right_padding = self.STRING_WIDTH - total_used_width
        
        # å…¨è§’ã‚¹ãƒšãƒ¼ã‚¹ã‚’æŒ¿å…¥ã™ã‚‹ã®ã§ã€ã€Œå¯å¤‰ã‚¹ãƒšãƒ¼ã‚¹ã®æ•°ã€ã¯æ•´æ•°é™¤ç®—ã§1/2ã«ã™ã‚‹
        right_padding //= 2
        
        # å³å´ã‚¹ãƒšãƒ¼ã‚¹ãŒãƒã‚¤ãƒŠã‚¹ã«ãªã‚‰ãªã„ã‚ˆã†ã«èª¿æ•´
        if right_padding < 0:
            right_padding = 0  # é•·ã™ãã‚‹å ´åˆã¯ãã®ã¾ã¾
        
        right_paffing_spases = 'ã€€' * right_padding
        
        # çµæœã®ãƒ‡ã‚³ãƒ¬ãƒ¼ãƒˆã—ãŸæ–‡å­—åˆ—
        decorated = f"{self.FIXED_LINE}{self.FIXED_SPACE}{handled_message}{right_paffing_spases}{self.FIXED_SPACE}{self.FIXED_LINE}"
        print(decorated)

# -----------------------------------------------
# æç”»ã‚¯ãƒ©ã‚¹
# -----------------------------------------------

class Renderer(Protocol):
    def on_TileDiscarded(self, event):
        pass

class CUIRenderer:
    def __init__(self):
        self.is_tile_face_visible = True 
        self.hidden_tile = "ğŸ€†"  # è¡¨ç¤ºã®ã¿ã€Œè£ç‰Œã€
    
    def kariton_display_tiles(self, top_row, bottom_row)
    """ç‰Œã®è¡¨ç¤ºï¼ˆå†…å®¹ãŒON/OFFã§åˆ‡ã‚Šæ›¿ãˆå¯èƒ½ï¼‰"""
        if self.show_content:
            print(f"{top_row[0]} {top_row[1]}")
            print(f"{bottom_row[0]} {bottom_row[1]}")
        else:
            print(f"{self.hidden_tile} {self.hidden_tile}")
            print(f"{self.hidden_tile} {self.hidden_tile}")
    
    def tile_discarded(self, event):
        print(EVENT_MESSAGE.TILE_DISCARDED)

# -----------------------------------------------
# ã‚¤ãƒ™ãƒ³ãƒˆã‚¯ãƒ©ã‚¹ã®åŸºåº•ã‚¯ãƒ©ã‚¹
# -----------------------------------------------

@dataclass(frozen=True)
class Event():
    pass

# -----------------------------------------------
# ã‚¤ãƒ™ãƒ³ãƒˆå±¥æ­´
# -----------------------------------------------

class EventHistory:
    def __init__(self):
        self._events: list[Event] = []

    def _add_event(self, event: Event):
        self._events.append(event)

    def get_events_by_instance(self, event: Event):
        [return event for event in self.events if event.__class__.__name__]

    def get_events_by_class(self, cls: type[Event]) -> list[Event]:
        return [event for event in self._events if isinstance(event, cls)]

    def get_last_event(self, cls: type[Event]) -> Event | None:
        for event in reversed(self._events):
            if isinstance(event, cls):
                return event
        return None


# -----------------------------------------------
# ã‚¤ãƒ™ãƒ³ãƒˆãƒã‚¹ ã€€ã‚µãƒ–ã‚¹ã‚¯ãƒ©ã‚¤ãƒ–ã¨é€šçŸ¥ã‚’è¡Œã†
# -----------------------------------------------

class EventBus:
    def __init__(self, event_history):
        self.subscribers = []
        self.buffer = []
        self.event_history = event_history

    def subscribe(self, handler):
        self._subscribers.append(handler)

    def emit(self, event):
        self.buffer.append(event)

    def flush(self):
        for event in self.buffer:
            self.__add_event_to_event_history__(event)
            for subscribers in self.subscribers:
                subscribers.handle(event)
        self.buffer.clear()

    # ãƒãƒƒãƒ•ã‚¡å‹ã«ã—ãŸã®ã§æ¶ˆã™äºˆå®šã ãŒæ¬¡ã®ä¿å­˜ã¾ã§æ®‹ã™
    # def publish(self, event):
    #    for handler in self.subscribers:
    #        handler.handle(event)
    #    self.__add_event_to_event_history__(event)

    def __add_event_to_event_history__(self, event):
        self.event_history._add_event(event)
        
    def get_events(self, cls: type[Event]) -> list[Event]:
        return self.event_history.get_events_by_class(cls)

    def get_last_event(self, cls: type[Event]) -> Event | None:
        return self.event_history.get_last_event(cls)

# -----------------------------------------------
# ã‚¤ãƒ™ãƒ³ãƒˆã‚’ãƒãƒ³ãƒ‰ãƒ«ã™ã‚‹ã‚¯ãƒ©ã‚¹é–¢ä¿‚
# -----------------------------------------------

class BaseEventHandler:
    """ ãƒãƒ³ãƒ‰ãƒ«å‡¦ç†ã®ãƒ­ã‚¸ãƒƒã‚¯ã ã‘ã‚’æŒã¤ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã®åŸºåº•ã‚¯ãƒ©ã‚¹ """
    def handle(self, event: Event):  # ãƒ©ãƒƒãƒ‘ãƒ¼ å¤–éƒ¨ãŒhandleã‚’æ…£ç¿’çš„ã«ä½¿ã£ã¦ã‚‚OK
        self.dispatch(event)
    
    def dispatch(self, event: Event):
        method_name = f"on_{event.__class__.__name__}"
        handler = getattr(self, method_name, self.default)
        handler(event)

    def default(self, event: Event):
        raise NotImplementedError(
            f"No handler for {event.__class__.__name__}"
        )


class GameEventHandler(BaseEventHandler)
    pass

class RendererEventHandler(BaseEventHandler):
    """ æç”»é–¢ä¿‚ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚¯ãƒ©ã‚¹ """
    def __init__(self, renderer):
        self.renderer = renderer
    
    def on_DisplayKaritonTilesEvent(self, event):
        self.renderer.kariton_display_tiles(event.top_row, event.bottom_row)
        
    def on_TileDiscarded(self, event):
        self.renderer.tile_discarded(event)
        
        
class ReplayRendererEventHandler(BaseEventHandler):
    """ ãƒªãƒ—ãƒ¬ã‚¤æ™‚ã¨å¯¾å±€æ™‚ã§ã®æç”»æ¼”å‡ºã‚’åˆ†ã‘ã‚‹ç‚ºã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚¯ãƒ©ã‚¹ """
    pass


class CompositeEventHandler(BaseEventHandler):
    """
    å­ EventHandlerã‚’addã§è¿½åŠ ã—ä¿æŒã—ã€å…¨ã¦ã®ãã‚Œã‚‰ã«handleã§é€šçŸ¥ã§ãã‚‹
    ã®ã§ã€å‘¼ã³å‡ºã—å´ã¯ã“ã‚Œã ã‘ã‚’ã‚‚ã£ã¦ã„ã‚Œã°ã„ã„ã€‚
    ãŸã ã—ãƒ“ãƒ«ãƒ€ãƒ¼ã§ç”Ÿæˆã—ã¾ã—ã‚‡ã†ã­
    """
    def __init__(self):
        self.children: list[BaseEventHandler] = []

    def add_handler(self, handler: BaseEventHandler):
        """å­ EventHandler ã‚’è¿½åŠ """
        self.children.append(handler)

    def handle(self, event: 'Event'):
        """å…¨ã¦ã®å­ã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’é€šçŸ¥"""
        for child in self.children:
            child.handle(event)

    def default(self, event: 'Event'):
        """å¿…è¦ãªã‚‰ Composite è‡ªä½“ã® default å‡¦ç†ã‚‚å¯èƒ½"""
        # åŸºæœ¬ã¯ä½•ã‚‚ã—ãªã„ã€ã¾ãŸã¯è¦ªã‚¯ãƒ©ã‚¹ã® default ã‚’å‘¼ã¶
        super().default(event)


class EventHandlerBuilder:
    """
    CompositeEventHandler ã«å­EventHandler ã‚’è¿½åŠ ã™ã‚‹ãŸã‚ã® Builder ã‚¯ãƒ©ã‚¹
    Attributes:renderer: Renderer ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
    """
    def __init__(self, renderer):
        self.renderer = renderer

    def build(self) -> CompositeEventHandler:
        root = CompositeEventHandler()
        root.add_handler(RendererEventHandler(self.renderer))
        root.add_handler(LoggingEventHandler())
        return root

# -----------------------------------------------
# å€‹åˆ¥ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚¯ãƒ©ã‚¹
# -----------------------------------------------

@dataclass(frozen=True)
class WindTileShuffledEvent(Event):
    shuffled_tiles: Sequence[Tile]
    shuffler: PlayerId

@dataclass(frozen=True)
class WindTileSelectedEvent(Event):
    pass
    
@dataclass(frozen=True)
class DisplayKaritonTilesEvent:
    top_row: tuple[int, int]
    bottom_row: tuple[int, int]
    
@dataclass(frozen=True)
class TileDiscardedEvent(Event):
    player_id: int
    tile: str

# -----------------------------------------------
# ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
# -----------------------------------------------

class NetworkClient:
    def wait_for_shuffle_complete(self):
        self.receive_event(WindTileShuffledEvent)

    def receive_event(self, event_class=None, timeout=None):
        start = time.time()

        while True:
            event = self._poll_network_event()

            if event_class is None or isinstance(event, event_class):
                return event

            if timeout and (time.time() - start) > timeout:
                raise TimeoutError(f"{event_class.__name__} timeout")

    # å˜ä¸€ã‚¤ãƒ™ãƒ³ãƒˆã‚¯ãƒ©ã‚¹ã§ãã®å±æ€§ãŠevent_typeã§ã‚¤ãƒ™ãƒ³ãƒˆã‚’è­˜åˆ¥ã—ã¦ã„ãŸé ƒã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³
    # æ¬¡ã®ã‚³ãƒ¼ãƒ‰ä¿å­˜ã¾ã§ã¯ä¸€å¿œä¿æŒã—ã€ãã®å¾Œã¯å‰Šé™¤ã™ã‚‹
    # ã“ã†ã„ã†ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã¯ã‚¢ãƒ³ãƒãƒ‘ã‚¿ãƒ¼ãƒ³ã ã£ã¦ã‚¹ã‚²ãƒ¼æ˜”ã«ã‚¹ã‚²ãƒ¼èª­ã‚“ã æ°—ã„ã™ã£ã‘ã©
    # é›†å›£é–‹ç™ºã˜ã‚ƒãªã„ã—æœªæ¥ã®è‡ªåˆ†ãŒå›°ã‚‹ã ã‘ãªã®ã§çŸ¥ã‚‰ã‚“ãŒãªå¤§è–å ‚
    # ãµã–ã‘ãªã„ã¨ã‚„ã£ã¦ã‚‰ã‚Œãªã„ãœï¼ã€€ã¡ãƒãã—ã‚‡ã‰ã„ï¼
    # éŠã³å¿ƒã‚’ä»–äººã®è¨€è‘‰ã‚„å¸¸è­˜ã‚„ã‚‰å·¥æ¥­ã‚„ã‚‰ã«æ®ºã•ã‚Œã‚“ãªã‚ˆå¤§äººã‚ˆ
    # ãªã‚“ãªã‚‰ã“ã®ã‚¯ã‚½ãƒ‡ã‚«ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆãƒãƒ£ãƒ³ã‚¯ã‚’ç›®å°ã«ã§ãã‚‹ã—ãªï¼ï¼ï¼ã¨ã‹æ›¸ã„ã¨ã“
    #
    # def wait_for_shuffle_complete(self):
    #     event = self.receive_event()
    #     assert event.type == "WIND_SHUFFLE_DONE"
    #
    # def receive_event(self, event_type=None, timeout=None):
    #     """
    #     æ±ç”¨ã‚¤ãƒ™ãƒ³ãƒˆå—ä¿¡
    #     - event_type: å¾…ã¤ã‚¤ãƒ™ãƒ³ãƒˆã®ç¨®é¡ã€‚Noneãªã‚‰ä½•ã§ã‚‚å—ã‘å–ã‚‹
    #     - timeout: å¾…ã¤ç§’æ•°
    #     """
    #     start = time.time()
    #     while True:
    #         event = self._poll_network_event()
    #         if event_type is None or event.type == event_type:
    #             return event
    #         if timeout and (time.time() - start) > timeout:
    #             raise TimeoutError(f"{event_type}ã®ã‚¤ãƒ™ãƒ³ãƒˆå—ä¿¡ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ")
    # 
    # def _poll_network_event(self):
    #     """
    #     å®Ÿéš›ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‹ã‚‰ã‚¤ãƒ™ãƒ³ãƒˆã‚’1ã¤å–å¾—ã™ã‚‹ï¼ˆãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã§ã‚‚éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã§ã‚‚å¯ï¼‰
    #     """
    #     # ä»®ï¼šãƒ¢ãƒƒã‚¯ã®å ´åˆã¯ãƒ€ãƒŸãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿”ã™
    #     time.sleep(0.1)
    #     return Event(type="WIND_SHUFFLE_DONE")

# class MockNetworkClient:
#     def wait_for_shuffle_complete(self):
#         print("ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒé¢¨ç‰Œã‚’æ··ãœã¦ã„ã¾ã™...")
#         time.sleep(0.1)

class MockNetworkClient(NetworkClient):
    def _poll_network_event(self):
        time.sleep(0.1)
        return WindTileShuffledEvent()


# -----------------------------------------------
# å…¥åŠ›
# -----------------------------------------------

class InputProvider(Protocol):
    pass

class CUIInputProvider:
    LEFT = "LEFT"
    RIGHT = "RIGHT"
    UP = "UP"
    DOWN = "DOWN"
    QUIT = "QUIT"

    def get_key(self):
        return input()  # æœ¬ç‰©ãªã‚‰ curses ç­‰

# -----------------------------------------------
# ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ç’°å¢ƒãŒå…¥åŠ›ãŒå¯èƒ½ãªç’°å¢ƒã‹åˆ¤å®šã™ã‚‹
# -----------------------------------------------

class CUIAvailabilityDetector:
    def is_available(self) -> bool:
        try:
            return sys.stdin.isatty()
        except:
            return False

    # def stdin_check
    #     if sys.stdin.isatty():
    #         print("CUIå…¥åŠ›ãŒå¯èƒ½ãªç’°å¢ƒã§ã™")
    #         user_input = input("ä½•ã‹å…¥åŠ›ã—ã¦ãã ã•ã„: ")
    #     else:
    #         print("CUIå…¥åŠ›ãŒã§ããªã„ç’°å¢ƒã§ã™")
    # 
    # def can_interact():
    #         return sys.stdin.isatty() and sys.stdout.isatty()
    # 
    #     if not can_interact():
    #         print("å¯¾è©±ãƒ¢ãƒ¼ãƒ‰ä¸å¯ã€‚è‡ªå‹•å‡¦ç†ã«åˆ‡ã‚Šæ›¿ãˆã¾ã™ã€‚")
    #         sys.exit(1)


# -----------------------------------------------
# Commandãƒ‘ã‚¿ãƒ¼ãƒ³ã®CommandåŸºåº•ã‚¯ãƒ©ã‚¹
# -----------------------------------------------

class Command(ABC):
    @abstractmethod
    def execute(self):
        pass


# -----------------------------------------------
# Commandãƒ‘ã‚¿ãƒ¼ãƒ³ã®ãƒ¬ã‚·ãƒ¼ãƒãƒ¼
# -----------------------------------------------

class WindTileShuffleReceiver:
    """
    Receiver å®Ÿéš›ã®ãƒ‰ãƒ¡ã‚¤ãƒ³çš„å‡¦ç†å†…å®¹ã‚’ä¿æŒã™ã‚‹
    é¢¨ç‰Œã‚’2ï¼Š2ã§è¡¨ç¤ºã™ã‚‹äº‹ã‚’å‰æã«ã€å·¦å³åˆ—å…¥ã‚Œæ›¿ãˆã€ä¸Šä¸‹æ®µå…¥ã‚Œæ›¿ãˆã€
    æ™‚è¨ˆå›ã‚Šã€åæ™‚è¨ˆå›ã‚Šå›ã‚Šãªã©ã®æ··ãœå‡¦ç†ã‚’å®šç¾©ã™ã‚‹
    è‹¥å¹²éš ã—è¦ç´ æ„Ÿã®ã‚ã‚‹å‡¦ç†ã¨ã—ã¦æ–œã‚åŒå£«ã®äº¤æ›2ãƒ‘ã‚¿ãƒ¼ãƒ³ãªã©ã‚‚ã‚ã‚‹
    """
    def __init__(self, tiles):
        self.tiles = tiles  # 4æšã®é¢¨ç‰Œï¼ˆ2x2é…ç½®ãªã©ï¼‰

    def swap_rows(self):
        self.tiles[0], self.tiles[1] = self.tiles[1], self.tiles[0]

    def swap_cols(self):
        self.tiles[0][0], self.tiles[0][1] = self.tiles[0][1], self.tiles[0][0]
        self.tiles[1][0], self.tiles[1][1] = self.tiles[1][1], self.tiles[1][0]

    def rotate_clockwise(self):
        a, b = self.tiles[0]
        c, d = self.tiles[1]
        self.tiles = [[c, a], [d, b]]

    def rotate_counter_clockwise(self):
        a, b = self.tiles[0]
        c, d = self.tiles[1]
        self.tiles = [[b, d], [a, c]]

    # â†˜â†–ï¼ˆå·¦ä¸Š â†” å³ä¸‹ï¼‰
    def swap_main_diagonal(self):  # def swap_top_left_and_bottom_right(self):
        self.tiles[0][0], self.tiles[1][1] = self.tiles[1][1], self.tiles[0][0]

    # â†—â†™ï¼ˆå³ä¸Š â†” å·¦ä¸‹ï¼‰
    def swap_anti_diagonal(self): # def swap_top_right_and_bottom_left(self):
        self.tiles[0][1], self.tiles[1][0] = self.tiles[1][0], self.tiles[0][1]
        

# -----------------------------------------------
# Commandãƒ‘ã‚¿ãƒ¼ãƒ³ã¯å„ç¨®ã‚³ãƒãƒ³ãƒ‰ã‚¯ãƒ©ã‚¹ç¾¤
# -----------------------------------------------

class UserShuffleCommand(Command):
    """
    ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå…¥åŠ›ã‚’ä½¿ã£ã¦ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã™ã‚‹ã‚³ãƒãƒ³ãƒ‰
    å·¦ã‚’æŠ¼ã™ã¨åæ™‚è¨ˆå›ã‚Šã«
    å³ã‚’æŠ¼ã™ã¨æ™‚è¨ˆå›ã‚Šã«
    ä¸Šã‚’æŠ¼ã™ã¨ä¸Šä¸‹æ®µã‚’å…¥ã‚Œæ›¿ãˆ
    ä¸‹ã‚’æŠ¼ã™ã¨å·¦å³åˆ—ã‚’å…¥ã‚Œæ›¿ãˆã‚‹
    """
    def __init__(self, shuffle_receiver, input_provider):
        self.shuffle_receiver = shuffle_receiver
        self.input = input_provider

    def execute(self):
        while True:
            key = self.input.get_key()

            if key == "LEFT":
                self.shuffle_receiver.rotate_counter_clockwise()
            elif key == "RIGHT":
                self.shuffle_receiver.rotate_clockwise()
            elif key == "UP":
                self.shuffle_receiver.swap_rows()
            elif key == "DOWN":
                self.shuffle_receiver.swap_cols()
            elif key == "a":
                self.shuffle_receiver.swap_main_diagonal()
            elif key == "s":
                self.shuffle_receiver.swap_anti_diagonal()
            elif key in ("ENTER", "q", "z", "x"):
                break


class CpuShuffleCommand(Command):
    """
    CPUãŒã‚·ãƒ£ãƒƒãƒ•ãƒ«ã™ã‚‹å ´åˆã®ã‚³ãƒãƒ³ãƒ‰
    é¢¨ç‰Œã‚·ãƒ£ãƒƒãƒ•ãƒ«ã®åˆ¶é™æ™‚é–“ã‚’5ç§’ã¨ã—ã¦5ç§’é–“ã«äººé–“ãŒã‚¬ãƒãƒ£æŠ¼ã—ã§ã§ãã‚‹æœ€å¤§æ‰‹æ•°ã‚’è€ƒãˆã‚‹
    ã–ã£ãã‚Šç¾å®Ÿçš„ãªç›®å®‰ï¼š
    ç‰‡æ‰‹ã§ã‚­ãƒ¼æŠ¼ã—ã™ã‚‹å ´åˆã€äººé–“ã¯ 1ç§’ã«ç´„5ã€œ6å› ãŒé™ç•Œï¼ˆé«˜é€Ÿã‚¿ãƒƒãƒ—ï¼‰
    ä¸¡æ‰‹ä½¿ã†ãªã‚‰ 1ç§’ã«10ã€œ15å› ç¨‹åº¦
    5ç§’ãªã‚‰ 50ã€œ75å›ç¨‹åº¦ ã¨è€ƒãˆã‚Œã°ååˆ†
    CPU ã®æ‰‹æ•°è¨­å®šã«åæ˜ ã•ã›ã‚‹ãªã‚‰ã€50æ‰‹ã€œ100æ‰‹ç¨‹åº¦ ã«ã™ã‚Œã°è‡ªç„¶ãªæ··ãœå¼·ã•ã‹
    ã¨ã¯è¨€ãˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä¸­ã«ã¯ä¸€å›ã‚‚æ··ãœãªã„äººã‚‚å±…ã‚‹ã ã‚ã†ãªã
    ãªã®ã§0, 101ã«ã—ãŸã‘ã©ã€ã“ã®0ãŒã‚‚ã—ä½•ã‹ä¸éƒ½åˆã‚’ç”Ÿã‚€ã®ã§ã‚ã‚Œã°1ã«ã™ã‚‹
    """
    def __init__(self, shuffle_receiver, steps = random.randint(0, 101)):
        self.shuffle_receiver = shuffle_receiver
        self.steps = steps

    def execute(self):
        ops = [
            self.shuffle_receiver.swap_rows,
            self.shuffle_receiver.swap_cols,
            self.shuffle_receiver.rotate_clockwise,
            self.shuffle_receiver.rotate_counter_clockwise
        ]
        for _ in range(self.steps):
            random.choice(ops)()


class NetUserShuffleCommand(Command):
    """ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®ä»–ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚·ãƒ£ãƒƒãƒ•ãƒ«ã™ã‚‹å ´åˆã®ã‚³ãƒãƒ³ãƒ‰"""
    def __init__(self, network_client):
        self.client = network_client

    def execute(self):
        self.client.wait_for_shuffle_complete()

# -----------------------------------------------
# ã‚³ãƒãƒ³ãƒ‰ãƒ“ã‚¸ã‚¿ãƒ¼ã€€ã‚³ãƒãƒ³ãƒ‰ï¼ˆå‡¦ç†ã€æ–¹æ³•ï¼‰ã‚’æŒã¤è¨ªå•è€…
# -----------------------------------------------

class ShuffleCommandVisitor:
    def visit_user(self, mode):
        return UserShuffleCommand()

    def visit_cpu(self, mode):
        return CPUShuffleCommand()
        
    def visit_net_user(self, mode):
        return CPUShuffleCommand()

# -----------------------------------------------
# ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ¢ãƒ¼ãƒ‰ï¼ˆè‡ªåˆ†/CPU/ä»–äººï¼‰ã«ä¾ã£ã¦å¯¾å¿œã‚³ãƒãƒ³ãƒ‰ã‚’ç”Ÿæˆã™ã‚‹ã‚¯ãƒ©ã‚¹ç¾¤
# -----------------------------------------------

class BasePlayerMode:
    """ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ¢ãƒ¼ãƒ‰ã®åŸºåº•ã‚¯ãƒ©ã‚¹"""
    def create_shuffle_command(self, shuffler):
        raise NotImplementedError

class UserMode(BasePlayerMode):
    """ãƒ¦ãƒ¼ã‚¶ãƒ¼è‡ªèº«ãŒãƒ—ãƒ¬ã‚¤ã™ã‚‹å ´åˆã®ãƒ¢ãƒ¼ãƒ‰"""
    def __init__(self, input_provider):
        self.input = input_provider
        
    def accept_visitor(self, visitor):
        return visitor.visit_user(self)

    # æ—§å®Ÿè£…
    # def create_shuffle_command(self, shuffler):
    #    return UserShuffleCommand(shuffler, self.input)

class CpuMode(BasePlayerMode):
    """ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ¢ãƒ¼ãƒ‰"""
    def accept_visitor(self, visitor):
        return visitor.visit_cpu(self)
    
    # def create_shuffle_command(self, shuffler):
    #    return CpuShuffleCommand(shuffler)

class NetUserMode(BasePlayerMode):
    """ãƒãƒƒãƒˆä¸Šã®ä»–äººã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¢ãƒ¼ãƒ‰"""
    def __init__(self, client):
        self.client = client

    def accept_visitor(self, visitor):
        return visitor.visit_net_user(self)

    # def create_shuffle_command(self, shuffler):
    #    return NetUserShuffleCommand(self.client)
        
# -----------------------------------------------
# ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
# -----------------------------------------------

class Player:
    def __init__(self, player_mode):
        self.mode = player_mode
        

# -----------------------------------------------
# ã‚²ãƒ¼ãƒ ã‚µãƒ¼ãƒ“ã‚¹ã€€Facadeãƒ‘ã‚¿ãƒ¼ãƒ³çš„ã«ã‚µãƒ–ã‚·ã‚¹ãƒ†ãƒ ã‚’ã¾ã¨ã‚ã‚‹ãœã‚ˆ
# -----------------------------------------------

class GameServices:
    """ã‚µãƒ–ã‚·ã‚¹ãƒ†ãƒ ã‚’çºã‚ã¦æ¸¡ã™ç‚ºã®Facadeï¼ˆã«è²¬å‹™ã‚’å¾¹ã™ã‚‹äº‹ï¼‰"""
    def __init__(self, input_provider, network_client, event_bus):
        self.input_provider = input_provider
        self.network_client = network_client
        self.events_bus = event_bus
        

# -----------------------------------------------
# çŠ¶æ…‹é·ç§»ã‚·ã‚¹ãƒ†ãƒ ï¼ˆState Machineï¼‰
# -----------------------------------------------

class State(ABC):
    """State==Phaseã®åŸºåº•ã‚¯ãƒ©ã‚¹"""
    @abstractmethod
    def enter(self):
        pass

    @abstractmethod
    def exit(self):
        pass

    @abstractmethod
    def update(self):
        pass

    @abstractmethod
    def reset(self):
        pass

    @abstractmethod
    def is_completed(self):
        pass

# -----------------------------------------------
# çŠ¶æ…‹é·ç§»ã‚·ã‚¹ãƒ†ãƒ ï¼ˆState Machineï¼‰
# -----------------------------------------------

class StateMachine:
    """çŠ¶æ…‹é·ç§»ã‚·ã‚¹ãƒ†ãƒ """
    def __init__(self, states, event_bus):
        self.states = states
        self.event_bus = event_bus
        self.current_index = 0
        self.current_state = None
        self.is_finished = False
        self.step_count = 0
        self.max_steps = 20

    def start(self):
        if not self.states:
            self.is_finished = True
            return
        self.current_state = self.states[0]
        self.current_state.enter()

    def update(self):
        if self.watchdog(): return

        if self.is_finished:
            return
        if self.current_state:
            self.current_state.update()
            if self.current_state.is_completed():
                self.change_state()

    def change_state(self):
        if self.current_state.is_completed():
            self.current_state.exit()
            self.current_index += 1
            if self.current_index >= len(self.states):
                self.is_finished = True
            else:
                self.current_state = self.states[self.current_index]
                self.current_state.enter()
            
    def reset(self):
        self.current_index = 0
        self.current_state = self.states[0] if self.states else None
        self.is_finished = False
        for state in self.states:
            if hasattr(state, "reset"):
                state.reset()

    def watchdog(self):
        self.step_count += 1
        if self.step_count >= self.max_steps:
            self.event_bus.publish(
                SystemEvent(
                    TIMEOUT_DETECTED,
                    STATE_MACHINE_NOT_PROGRESSING
                )
            )
            self.event_bus.publish(LogEvent(FAIL_SAFE_MAX_LOOP_COUNT))
            self.is_finished = True
            return True

    def pause(self):
        pass

    def is_in_state(self):
        pass

    #def run_phase(self):
    #    command = self.current_state.get_command()
    #    command.execute()


# -----------------------------------------------
# ä»®æ±æ±ºã‚ï¼ˆå¸­æ±ºã‚ã€å ´æ±ºã‚ï¼‰ã«ã®ã¿ä½¿ç”¨ã™ã‚‹é¢¨ç‰Œ
# -----------------------------------------------

class InitialWindTiles:
    def __init__(self):
        self.tiles = [
            ("ğŸ€€", "æ±"),  # æ±
            ("ğŸ€", "å—"),  # å—
            ("ğŸ€‚", "è¥¿"),  # è¥¿
            ("ğŸ€ƒ", "åŒ—")   # åŒ—
        ]
        self.meaning = {
            "ğŸ€€": "æ±",
            "ğŸ€": "å—",
            "ğŸ€‚": "è¥¿",
            "ğŸ€ƒ": "åŒ—"
        }

# -----------------------------------------------
# é¢¨ç‰Œã‚·ãƒ£ãƒƒãƒ•ãƒ«ãƒ•ã‚§ãƒ¼ã‚º
# -----------------------------------------------

class WindTileShufflePhase(State):
    def __init__(self, event_bus, event_history):
        self.event_bus = event_bus
        self.event_history = event_history
        self.shuffle_done = False
        self.tiles = InitialWindTiles.tiles

    def enter(self):
        self.event_bus.publish(LogEvent(WIND_TILE_SHUFFLE_PHASE_START))
        self.execute()

    def exit(self):
        if not self.shuffle_done:
            self.event_bus.publish(LogEvent(WIND_TILE_SHUFFLE_PHASE_END))

    def update(self):
        pass

    def reset(self):
        self.shuffle_done = False

    def is_completed(self):
        return self.shuffle_done

    def initial_randomize_tiles(self):
        """å ´æ±ºã‚ã§èª°ã‹ãŒé¢¨ç‰Œã‚’æ··ãœã‚‹å‰ã«ã€è‡ªç„¶ã«ã°ã‚‰ã‘ãŸç‰Œã‚’å†ç¾ã€ç”¨æ„ã™ã‚‹"""
        random.shuffle(self.tiles)
        return [self.tiles[0][0], self.tiles[1][0]], [self.tiles[2][0], self.tiles[3][0]]

    # def shuffle(self):
    #     handle_shuffle()
    #     
    #     self.shuffle_done = True
    #     self.event_bus.publish(Event(WIND_TILE_SHUFFLED, shuffler=shuffler))
    #     return shuffler
        
    def _select_suffler(self):
        # return self.players[0]  # ä»®ï¼šå…ˆé ­
        return random.choice(self.players)

    # def get_command(self):
    #     player = self.select_suffler()
    #     return player.mode.create_shuffle_command(self.shuffler)
        
        # suffler = self.select_suffler()
        #
        # if suffler.kind == "human":
        #     return HumanShuffleCommand(self.shuffler, self.input)
        # if suffler.kind == "cpu":
        #     return CpuShuffleCommand(self.shuffler)
        # if suffler.kind == "network":
        #     return NetworkShuffleCommand(self.network)
        #
        # raise RuntimeError("unknown player type")

    def _get_visitor(self):
        return ShuffleCommandVisitor()

    def _get_command(self, suffler, visitor):
        return suffler.mode.accept_visitor(visitor)
        
    def execute(self):
        suffler = self._select_suffler()
        visitor = self._get_visitor()
        command = self._get_command(suffler, visitor)
        command.execute()

# xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
#
#
#
# åˆ¥ç«‹ã¦ã§å‹•ä½œç¢ºèªã‚’ã—ãŸé¢¨ç‰Œã‚·ãƒ£ãƒƒãƒ•ãƒ«ãƒ•ã‚§ã‚¤ã‚ºã®ã‚³ãƒ¼ãƒ‰
#     é †æ¬¡WindTileShufflePhaseã«å–ã‚Šè¾¼ã‚€
#
#
#
#

class WindTileShuffleGame:
    def __init__(self, event_history, is_player_shuffling=True, show_content=True):
        self.event_history = event_history  # ã‚¤ãƒ™ãƒ³ãƒˆãƒ’ã‚¹ãƒˆãƒªãƒ¼ã‚’ä¾å­˜æ€§æ³¨å…¥
        self.is_player_shuffling = is_player_shuffling  # ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ··ãœã‚‹ã‹
        self.show_content = show_content  # å†…å®¹è¡¨ç¤ºã®ãƒ•ãƒ©ã‚°

    def shuffle_for_cpu(self, shuffler):
        """CPUã«ã‚ˆã‚‹ã‚·ãƒ£ãƒƒãƒ•ãƒ«å‡¦ç†"""
        print(f"{shuffler}ãŒæ··ãœã¾ã—ãŸã€‚ãƒ©ãƒ³ãƒ€ãƒ ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã‚’å®Ÿè¡Œã—ã¾ã™...")
        top_row, bottom_row = self.initialize_tiles()
        self.display_tiles(top_row, bottom_row)

        # ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨˜éŒ²
        event = ShuffleCompletedEvent((top_row, bottom_row), shuffler)
        self.event_history.add_event(event)

    def shuffle_for_player(self, shuffler):
        """ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã‚ˆã‚‹ã‚·ãƒ£ãƒƒãƒ•ãƒ«å‡¦ç†"""
        print(f"{shuffler}ãŒæ··ãœã¾ã™ã€‚\n")
        top_row, bottom_row = self.initialize_tiles()
        self.display_tiles(top_row, bottom_row)

        # ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨˜éŒ²
        event = ShuffleCompletedEvent((top_row, bottom_row), shuffler)
        self.event_history.add_event(event)

        print("\næ“ä½œæ–¹æ³•: 'q' ã§çµ‚äº†")
        user_input = self.get_input("æ¬¡ã«æ“ä½œã—ãŸã„å†…å®¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆçµ‚äº†ã¯ 'q'ï¼‰ï¼š")
        if user_input and user_input.lower() == 'q':
            print("ã‚·ãƒ£ãƒƒãƒ•ãƒ«çµ‚äº†ã€‚ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’çµ‚äº†ã—ã¾ã™ã€‚")
        else:
            print(f"ç„¡åŠ¹ãªå…¥åŠ›: {user_input}")
            print("ã‚·ãƒ£ãƒƒãƒ•ãƒ«çµ‚äº†ã€‚ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’çµ‚äº†ã—ã¾ã™ã€‚")

    def wait_for_network_player_shuffling(self):
        """ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ··ãœã‚‹ã®ã‚’å¾…ã¤å‡¦ç†"""
        print("ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ··ãœã‚‹ã®ã‚’å¾…ã£ã¦ã„ã¾ã™...")
        time.sleep(3)  # ãƒ€ãƒŸãƒ¼å¾…æ©Ÿ
        print("ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚·ãƒ£ãƒƒãƒ•ãƒ«ãŒå®Œäº†ã—ã¾ã—ãŸã€‚\n")

    def handle_shuffle(self, shuffler):
        """æ··ãœã‚‹å‡¦ç†ã®ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã€CPUã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ï¼‰"""
        if self.is_player_shuffling:
            self.shuffle_for_player(shuffler)
        else:
            if not self.is_input_available():
                self.shuffle_for_cpu(shuffler)
            else:
                self.wait_for_network_player_shuffling()

    @staticmethod
    def is_input_available():
        """æ¨™æº–å…¥åŠ›ãŒä½¿ãˆã‚‹ã‹ã‚’åˆ¤å®š"""
        try:
            # å…¥åŠ›å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
            input("Press Enter to continue... (or wait for automatic shuffle)")
            return True
        except:
            return False

    def get_input(self, prompt):
        """æ¨™æº–å…¥åŠ›ãŒå¯èƒ½ã‹ã‚’ç¢ºèªã—ã€å…¥åŠ›ã‚’å—ã‘ä»˜ã‘ã‚‹"""
        if self.is_input_available():
            return input(prompt)  # æ¨™æº–å…¥åŠ›ãŒæœ‰åŠ¹ãªå ´åˆã¯æ™®é€šã«å…¥åŠ›ã‚’å—ã‘ä»˜ã‘ã‚‹
        else:
            print("æ¨™æº–å…¥åŠ›ãŒç„¡åŠ¹ãªç’°å¢ƒã§ã™ã€‚è‡ªå‹•ã‚·ãƒ£ãƒƒãƒ•ãƒ«ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚")
            return None  # æ¨™æº–å…¥åŠ›ãŒç„¡åŠ¹ãªã‚‰ None ã‚’è¿”ã™


if __name__ == "__main__":
    # å®Ÿè¡Œç”¨ã®ã‚³ãƒ¼ãƒ‰
    event_history = EventHistory()
    game = WindTileShuffleGame(event_history, is_player_shuffling=True)

    # ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã‚ˆã‚‹ã‚·ãƒ£ãƒƒãƒ•ãƒ«
    shuffler = "Player1"
    game.shuffle_for_player(shuffler)

    # ã‚¤ãƒ™ãƒ³ãƒˆå±¥æ­´ã®ç¢ºèª
    events = event_history.get_event_by_name("ShuffleCompletedEvent")
    print("\nã‚¤ãƒ™ãƒ³ãƒˆå±¥æ­´:")
    for event in events:
        print(f"ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã‚’æ‹…å½“ã—ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: {event.shuffler}")
        print(f"ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã•ã‚ŒãŸç‰Œ: {event.shuffled_tiles[0][0]} {event.shuffled_tiles[0][1]}")
        print(f"                    {event.shuffled_tiles[1][0]} {event.shuffled_tiles[1][1]}")
        print("---")

    # ã‚·ãƒ£ãƒƒãƒ•ãƒ«å¾Œã€ç„¡é™ãƒ«ãƒ¼ãƒ—ã‚’é˜²ããŸã‚ã«é©åˆ‡ã«çµ‚äº†
    print("ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’çµ‚äº†ã—ã¾ã™ã€‚")

#
#
#
#
#  ã“ã“ã¾ã§
# 
#
#
# xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

# -----------------------------------------------
# é¢¨ç‰Œé¸æŠãƒ•ã‚§ãƒ¼ã‚º
# -----------------------------------------------

class WindTileSelectionPhase(State):
    def __init__(self, event_bus, event_history):
        self.event_bus = event_bus
        self.event_history = event_history
        self.selection_done = False

    def enter(self):
        self.event_bus.publish(LogEvent(WIND_TILE_SELECTION_PHASE_START))
        self.selection()

    def exit(self):
        self.event_bus.publish(LogEvent(WIND_TILE_SELECTION_PHASE_END))

    def update(self):
        pass

    def reset(self):
        self.selection_done = False

    def is_completed(self):
        return self.selection_done

    def selection(self):
        shuffled_event = self.event_history.get_event_by_type(WIND_TILE_SHUFFLED)
        shuffler = shuffled_event[0].extra_data["shuffler"]
        self.event_bus.publish(LogEvent(WIND_TILE_SELECTION_VALID, extra_data="é¢¨ç‰Œ1"))
        self.selection_done = True

# -----------------------------------------------
# ãƒ•ã‚§ãƒ¼ã‚ºé·ç§»ã®é †åºã‚’å®šç¾©ã™ã‚‹å°æœ¬
# -----------------------------------------------

class PhaseTransitionOrder:
    """ãƒ•ã‚§ãƒ¼ã‚ºé·ç§»ã®é †åºã‚’åˆ—æŒ™"""
    phase_names = [
        WindTileShufflePhase,
        WindTileSelectionPhase
    ]

# -----------------------------------------------
# ã‚·ãƒ¼ãƒ³ç®¡ç†ã‚¯ãƒ©ã‚¹ï¼ˆå¤§ããªé·ç§»ï¼‰
# -----------------------------------------------

class Scene(ABC):
    """ã‚·ãƒ¼ãƒ³ç®¡ç†ã‚¯ãƒ©ã‚¹"""
    def __init__(self, event_bus, event_history):
        self.event_bus = event_bus
        self.event_history = event_history

    @abstractmethod
    def on_enter(self):
        pass

    @abstractmethod
    def on_exit(self):
        pass

    @abstractmethod
    def update(self):
        pass

    @abstractmethod
    def reset(self):
        pass

    @abstractmethod
    def is_finished(self):
        pass

# -----------------------------------------------
# ã‚¿ã‚¤ãƒˆãƒ«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ç”»é¢ã‚·ãƒ¼ãƒ³
# -----------------------------------------------

class TitleScene(Scene):
    def __init__(self, event_bus, event_history):
        super().__init__(event_bus, event_history)
        self.event_bus = event_bus
        self.event_history = event_history
        self._is_finished = False

    def on_enter(self):
        self.event_bus.publish(LogEvent(TITLE_SCENE_START))

    def on_exit(self):
        self.event_bus.publish(LogEvent(TITLE_SCENE_END))
 
    def update(self):
        self.mark_as_finished()

    def reset(self):
        self._is_finished = False

    def is_finished(self):
        return self._is_finished

    def mark_as_finished(self):
        if not self._is_finished:
            self._is_finished = True
            
    def display_menu(self):  # ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®è¡¨ç¤º
        pass

# -----------------------------------------------
# è©¦åˆã‚·ãƒ¼ãƒ³
# -----------------------------------------------

class MatchScene(Scene):
    def __init__(self, event_bus, event_history):
        super().__init__(event_bus, event_history)
        self.state_machine = StateMachine(
            [
                WindTileShufflePhase(event_bus, event_history),
                WindTileSelectionPhase(event_bus, event_history)
            ],
            event_bus
        )
        self.event_bus = event_bus
        self.event_history = event_history
        self._is_finished = False

    def on_enter(self):
        self.event_bus.publish(LogEvent(MATCH_SCENE_START))
        self.start_match()

    def on_exit(self):
        self.event_bus.publish(LogEvent(MATCH_SCENE_END))

    def update(self):
        self.state_machine.update()
        if self.state_machine.is_finished:
            self.mark_as_finished()

    def reset(self):
        self.state_machine.reset()
        self._is_finished = False

    def is_finished(self):
        return self._is_finished

    def mark_as_finished(self):
        if not self._is_finished:
            self._is_finished = True
            
    def start_match(self):
        self.state_machine.start()

# -----------------------------------------------
# è©¦åˆçµæœã‚·ãƒ¼ãƒ³
# -----------------------------------------------

class ResultScene(Scene):
    def __init__(self, event_bus, event_history):
        super().__init__(event_bus, event_history)
        self.event_bus = event_bus
        self.event_history = event_history
        self._is_finished = False

    def on_enter(self):
        self.event_bus.publish(LogEvent(RESULT_SCENE_START))
        self.show_result()

    def on_exit(self):
        self.event_bus.publish(LogEvent(RESULT_SCENE_END))

    def update(self):
        self.mark_as_finished()

    def reset(self):
        self._is_finished = False

    def is_finished(self):
        return self._is_finished

    def mark_as_finished(self):
        if not self._is_finished:
            self._is_finished = True

    def show_result(self):
        pass

# -----------------------------------------------
# ã‚·ãƒ¼ãƒ³ã®æ¡ä»¶åˆ†å²ãªã©ã‚ã‚Šå¾—ã‚‹é †ç•ªã‚’ä¿æŒã™ã‚‹
# -----------------------------------------------

class SceneFlow:
    scene_names = [
        TitleScene,
        MatchScene,
        ResultScene
    ]

# -----------------------------------------------
# ã‚·ãƒ¼ãƒ³ã‚’é·ç§»ã•ã›ã‚‹
# -----------------------------------------------

class SceneTransitioner:
    def __init__(self, event_bus, event_history):
        self.event_bus = event_bus
        self.scene_order = SceneFlow.scene_names 
        self.current_scene_index = 0
        self.current_scene = self.scene_order[self.current_scene_index](event_bus, event_history)
        self.all_scene_done = False
        
    def run(self):
        """ã‚·ãƒ¼ãƒ³ã®å®Ÿè¡Œãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹"""
        self.current_scene.on_enter()

        MAX_LOOP = 10
        loop_count = 0

        while self.current_scene:
            loop_count += 1
            if loop_count >= MAX_LOOP:
                self.event_bus.publish(LogEvent(FAIL_SAFE_MAX_LOOP_COUNT))
                break        

            self.current_scene.update()

            if self.current_scene.is_finished():
                self.transition_to_next_scene()

            self.wait_seconds(0.01)

    def transition_to_next_scene(self):
        """æ¬¡ã®ã‚·ãƒ¼ãƒ³ã«é·ç§»"""
        self.current_scene.on_exit()
        self.current_scene_index += 1

        if self.current_scene_index >= len(self.scene_order):  # ã‚·ãƒ¼ãƒ³ã®é †ç•ªãŒçµ‚ã‚ã£ãŸã‚‰çµ‚äº†
            self.current_scene = None
            self.all_scene_done = True
        else:
            self.current_scene = self.scene_order[self.current_scene_index](self.current_scene.event_bus, self.current_scene.event_history)
            self.current_scene.on_enter()

    def wait_seconds(self, second):
        time.sleep(second)

    def request_scene_change(self, next_scene):
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã§å¼·åˆ¶çš„ã« Scene ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹"""
        if self.current_scene:
            self.current_scene.on_exit()
        self.current_scene = next_scene
        self.current_scene.reset()
        self.current_scene.on_enter()

    def go_to_match_scene(self, restart=False):
        match_scene = MatchScene(self.event_bus, self.event_history)
        if restart:
            match_scene.reset()  # Phaseã‚‚StateMachineã‚‚åˆæœŸåŒ–
        self.request_scene_change(match_scene)

# -----------------------------------------------
# ã‚²ãƒ¼ãƒ ç®¡ç†ã‚¯ãƒ©ã‚¹
# -----------------------------------------------

class GameSession:
    """ã‚²ãƒ¼ãƒ ã®é€²è¡Œã‚’ç®¡ç†ã™ã‚‹ã‚¯ãƒ©ã‚¹"""
    def __init__(self, event_bus, event_history):
        self.event_bus = event_bus
        self.event_history = event_history
        self.scene_transitioner = None

    def start_game(self):
        """ã‚²ãƒ¼ãƒ ã®é–‹å§‹å‡¦ç†"""
        self.scene_transitioner = SceneTransitioner(self.event_bus, self.event_history)
        self.event_bus.publish(LogEvent(GAME_START))
        self.scene_transitioner.run()
        self.end_game()

    def end_game(self):
        """ã‚²ãƒ¼ãƒ ã®çµ‚äº†å‡¦ç†"""
        self.event_bus.publish(LogEvent(GAME_END))
        # if self.scene_transitioner:
        #    self.scene_transitioner.request_scene_change(None)  # ã‚²ãƒ¼ãƒ çµ‚äº†æ™‚ã«ã‚·ãƒ¼ãƒ³é·ç§»ã‚’åœæ­¢

# -----------------------------------------------
# ã‚²ãƒ¼ãƒ åˆæœŸåŒ–ã‚¯ãƒ©ã‚¹
# -----------------------------------------------

class GameLauncher:
    def __init__(self):
        self.renderer = CUIRenderer()
        self.event_history = EventHistory()
        self.event_bus = EventBus(self.event_history)
        self.composite_handler = EventHandlerBuilder(renderer).build()
        self.event_bus.subscribe(composite_handler)
        self.game_session = GameSession(self.event_bus, self.event_history)

    def launch(self):
        self.game_session.start_game()

# -----------------------------------------------
# å®Ÿè¡Œ
# -----------------------------------------------
if __name__ == "__main__":
    game_launcher = GameLauncher()  # ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ–
    game_launcher.launch()
    
