import random

# ===============================
# ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›ãƒ©ãƒƒãƒ‘ãƒ¼
# ===============================
class Logger:
    def __init__(self, enabled=True):
        self.enabled = enabled

    def log(self, *args, **kwargs):
        if self.enabled:
            formatted_args = []
            for arg in args:
                if isinstance(arg, list):
                    formatted_args.append(", ".join(str(a) for a in arg))
                elif isinstance(arg, dict):
                    formatted_args.append(", ".join(f"{k}:{v}" for k, v in arg.items()))
                else:
                    formatted_args.append(str(arg))
            print(*formatted_args, **kwargs)

logger = Logger(enabled=True)

# ===============================
# ã‚²ãƒ¼ãƒ ã®æ®µéš
# ===============================
from enum import Enum, auto

class GamePhase(Enum):
    INIT = auto()
    KARITON = auto()
    TEMP_PARENT = auto()
    REAL_PARENT = auto()
    WALL_BUILD = auto()
    KAIMEN = auto()
    DONE = auto()

# ===============================
# é †ç•ªã¨åº§æ¨™ ï¼ OrderAndCoordinates
# ===============================
class TableOrder:
    wind_order = ["æ±", "å—", "è¥¿", "åŒ—"]  # é¢¨ã®ä¸¦ã³ç•ª
    sides = {"A": (1, 0), "B": (0, -1), "C": (-1, 0), "D": (0, 1)}  # å“ã®åº§æ¨™å®šç¾©
    clockwise_order = ["A", "D", "C", "B"]  # ç”»é¢åº§æ¨™ç³»ã«åˆã‚ã›ãŸæ™‚è¨ˆå›ã‚Š
    counter_clockwise_order = ["A", "B", "C", "D"]  # åŒã˜ãã®åæ™‚è¨ˆå›ã‚Š

    # æ™‚è¨ˆå›ã‚Š
    @staticmethod
    def next_clockwise(side):
        idx = TableOrder.clockwise_order.index(side)
        return TableOrder.clockwise_order[(idx + 1) % 4]

    # åŠæ™‚è¨ˆå›ã‚Š
    @staticmethod
    def next_counter_clockwise(side):
        idx = TableOrder.counter_clockwise_order.index(side)
        return TableOrder.counter_clockwise_order[(idx + 1) % 4]

# ===============================
# éº»é›€å“ã‚„å¸­ã‚„å ´é¢¨ã®ç®¡ç†
# ===============================
class SeatingManager:
    def __init__(self, players):
        self.players = players
        self.kariton_order = {}

    # é¢¨ç‰Œã‚’ç”¨æ„
    wind_tiles = ["æ±", "å—", "è¥¿", "åŒ—"]

    # ä»®æ±ã®æ±ºå®š
    def decide_kariton(self):
        mixer = random.choice(self.players)
        drawn = random.sample(self.wind_tiles, 4)
        for p, w in zip(self.players, drawn):
            p.initial_wind = w

        east = next(p for p in self.players if p.initial_wind == "æ±")
        east.seat = random.choice(["A", "B", "C", "D"])
        east.is_kariton = True

        self.kariton_order[east.seat] = east
        side = east.seat
        for wind in ["å—", "è¥¿", "åŒ—"]:
            side = TableOrder.next_counter_clockwise(side)
            p = next(p for p in self.players if p.initial_wind == wind)
            p.seat = side
            self.kariton_order[side] = p

        return mixer

    # ä»®è¦ªæ±ºå®šã¨è¦ªæ±ºå®š
    def decide_parent(self):
        # ä»®è¦ªæ±ºå®šéƒ¨
        east_side = next(s for s, p in self.kariton_order.items() if p.is_kariton)
        temp_side, _, d1, d2 = Dice.roll_and_get_target(east_side)
        temp_parent = self.kariton_order[temp_side]

        # è¦ªæ±ºå®šéƒ¨
        real_side, _, rd1, rd2 = Dice.roll_and_get_target(temp_parent.seat)
        real_parent = self.kariton_order[real_side]
        real_parent.is_parent = True

        self.assign_winds(real_parent.seat)

        # ä»®è¦ªã€è¦ªã€ä»®è¦ªæ±ºå®šæ™‚ã®å‡ºç›®2å€‹ã€è¦ªæ±ºå®šæ™‚ã®å‡ºç›®2å€‹ã‚’è¿”ã™
        return temp_parent, real_parent, d1, d2, rd1, rd2

    # å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å ´é¢¨ã‚’å‰²ã‚Šå½“ã¦ã‚‹
    def assign_winds(self, parent_side):
        parent = self.kariton_order[parent_side]
        parent.wind = "æ±"
        idx = TableOrder.counter_clockwise_order.index(parent_side)
        for wind in ["å—", "è¥¿", "åŒ—"]:
            idx = (idx + 1) % 4
            self.kariton_order[TableOrder.counter_clockwise_order[idx]].wind = wind

# ===============================
# ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¯ãƒ©ã‚¹
# ===============================
kana_chars = list("ã‚¢ã‚¤ã‚¦ã‚¨ã‚ªã‚«ã‚­ã‚¯ã‚±ã‚³ã‚µã‚·ã‚¹ã‚»ã‚½ã‚¿ãƒãƒ„ãƒ†ãƒˆãƒŠãƒ‹ãƒŒãƒãƒãƒãƒ’ãƒ•ãƒ˜ãƒ›ãƒãƒŸãƒ ãƒ¡ãƒ¢ãƒ¤ãƒ¦ãƒ¨ãƒ©ãƒªãƒ«ãƒ¬ãƒ­ãƒ¯ãƒ²ãƒ³ã‚¬ã‚®ã‚°ã‚²ã‚´ã‚¶ã‚¸ã‚ºã‚¼ã‚¾ãƒ€ãƒ‚ãƒ…ãƒ‡ãƒ‰ãƒãƒ“ãƒ–ãƒ™ãƒœãƒ‘ãƒ”ãƒ—ãƒšãƒ")

class Player:
    def __init__(self, name, type_="CPU"):
        self.name = name
        self.type = type_
        self.initial_wind = None  # ä»®ã§å¼•ã„ãŸé¢¨ç‰Œ
        self.seat = None  # A/B/C/D å¸­ï¼ˆå ´é¢¨ã¨ã¯åˆ¥ï¼‰
        self.wind = None  # æ±å—è¥¿åŒ—ï¼ˆæœ€çµ‚çš„ãªå®¶ï¼‰
        self.is_kariton = False
        self.is_parent = False
        self.wall = None  # Wallã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ

    def __repr__(self):
        return f"{self.name}({self.type}, seat={self.seat}, wind={self.wind})"

    @staticmethod
    def generate_player_name():
        return "".join(random.choices(kana_chars, k=random.randint(2, 4)))

# ===============================
# ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼
# ===============================
class PlayerFactory:
    @staticmethod
    def create_players():
        players = [Player(Player.generate_player_name()) for _ in range(3)]
        players.append(Player("ã‚ãªãŸ", type_="Human"))
        random.shuffle(players)
        return players

# ===============================
# ã‚µã‚¤ã‚³ãƒ­åˆ¤å®šå‡¦ç†
# ===============================
class Dice:
    @staticmethod
    def roll():
        return random.randint(1, 6), random.randint(1, 6)

    @staticmethod
    def get_target_player_by_total(roller_side, total):
        """ã‚µã‚¤ã‚³ãƒ­åˆè¨ˆå€¤ã‹ã‚‰å¯¾è±¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¾ºã‚’è¿”ã™"""
        move_table = {
            (5, 9): 0,
            (2, 6, 10): 1,
            (3, 7, 11): 2,
            (4, 8, 12): 3
        }

        steps = None
        for nums, step in move_table.items():
            if total in nums:
                steps = step
                break

        # åæ™‚è¨ˆå›ã‚Šã®é †ã«å¾“ã£ã¦å¯¾è±¡è€…ã‚’æ±ºå®š
        idx = TableOrder.counter_clockwise_order.index(roller_side)
        target_side = TableOrder.counter_clockwise_order[(idx + steps) % 4]
        return target_side

    @staticmethod
    def roll_and_get_target(roller_side):
        """ã‚µã‚¤ã‚³ãƒ­ã‚’1å›æŒ¯ã‚Šã€å¯¾è±¡ã®å¸­ã¨åˆè¨ˆå€¤ã¨ãƒ€ã‚¤ã‚¹ãã‚Œãã‚Œã®å€¤ã‚’è¿”ã™ï¼ˆç´”ç²‹ãªæ‰‹ç¶šãã®å…±é€šåŒ–ï¼‰"""
        d1, d2 = Dice.roll()
        total = d1 + d2
        target = Dice.get_target_player_by_total(roller_side, total)
        return target, total, d1, d2

# ===============================
# ä½¿ç”¨éº»é›€ç‰Œã®å®šç¾©ï¼ˆçµ¶å¯¾ã«å¤‰æ›´ç¦æ­¢ï¼‰
# ===============================
tiles = "ğŸ€‡,ğŸ€‡,ğŸ€‡,ğŸ€‡,ğŸ€ˆ,ğŸ€ˆ,ğŸ€ˆ,ğŸ€ˆ,ğŸ€‰,ğŸ€‰,ğŸ€‰,ğŸ€‰,ğŸ€Š,ğŸ€Š,ğŸ€Š,ğŸ€Š,ğŸ€‹èµ¤,ğŸ€‹,ğŸ€‹,ğŸ€‹,ğŸ€Œ,ğŸ€Œ,ğŸ€Œ,ğŸ€Œ,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€™,ğŸ€™,ğŸ€™,ğŸ€™,ğŸ€š,ğŸ€š,ğŸ€š,ğŸ€š,ğŸ€›,ğŸ€›,ğŸ€›,ğŸ€›,ğŸ€œ,ğŸ€œ,ğŸ€œ,ğŸ€œ,ğŸ€èµ¤,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€Ÿ,ğŸ€Ÿ,ğŸ€Ÿ,ğŸ€Ÿ,ğŸ€ ,ğŸ€ ,ğŸ€ ,ğŸ€ ,ğŸ€¡,ğŸ€¡,ğŸ€¡,ğŸ€¡,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€‘,ğŸ€‘,ğŸ€‘,ğŸ€‘,ğŸ€’,ğŸ€’,ğŸ€’,ğŸ€’,ğŸ€“,ğŸ€“,ğŸ€“,ğŸ€“,ğŸ€”èµ¤,ğŸ€”,ğŸ€”,ğŸ€”,ğŸ€•,ğŸ€•,ğŸ€•,ğŸ€•,ğŸ€–,ğŸ€–,ğŸ€–,ğŸ€–,ğŸ€—,ğŸ€—,ğŸ€—,ğŸ€—,ğŸ€˜,ğŸ€˜,ğŸ€˜,ğŸ€˜,ğŸ€€,ğŸ€€,ğŸ€€,ğŸ€€,ğŸ€,ğŸ€,ğŸ€,ğŸ€,ğŸ€‚,ğŸ€‚,ğŸ€‚,ğŸ€‚,ğŸ€ƒ,ğŸ€ƒ,ğŸ€ƒ,ğŸ€ƒ,ğŸ€†,ğŸ€†,ğŸ€†,ğŸ€†,ğŸ€…,ğŸ€…,ğŸ€…,ğŸ€…,ğŸ€„,ğŸ€„,ğŸ€„,ğŸ€„"

meaning = {
    "ğŸ€‡": "1m", "ğŸ€ˆ": "2m", "ğŸ€‰": "3m", "ğŸ€Š": "4m",
    "ğŸ€‹": "5m", "ğŸ€Œ": "6m", "ğŸ€": "7m", "ğŸ€": "8m", "ğŸ€": "9m",
    "ğŸ€‹èµ¤": "5mRed",
    "ğŸ€™": "1p", "ğŸ€š": "2p", "ğŸ€›": "3p", "ğŸ€œ": "4p",
    "ğŸ€": "5p", "ğŸ€": "6p", "ğŸ€Ÿ": "7p", "ğŸ€ ": "8p", "ğŸ€¡": "9p",
    "ğŸ€èµ¤": "5pRed",
    "ğŸ€": "1s", "ğŸ€‘": "2s", "ğŸ€’": "3s", "ğŸ€“": "4s",
    "ğŸ€”": "5s", "ğŸ€•": "6s", "ğŸ€–": "7s", "ğŸ€—": "8s", "ğŸ€˜": "9s",
    "ğŸ€”èµ¤": "5sRed",
    "ğŸ€€": "ton", "ğŸ€": "nan", "ğŸ€‚": "sha", "ğŸ€ƒ": "pei",
    "ğŸ€†": "haku", "ğŸ€…": "hatsu", "ğŸ€„": "chun"
}

# ===============================
# å£ç‰Œã®æ§‹é€ 
# ===============================
class Wall:
    def __init__(self):
        self.columns = []  # [[ä¸Š,ä¸‹], ...]

    def add_column(self, upper, lower):
        self.columns.append([upper, lower])

    def upper_row(self):
        return [col[0] for col in self.columns]

    def lower_row(self):
        return [col[1] for col in self.columns]

# ===============================
# å£ç‰Œã®ç®¡ç†
# ===============================
class WallManager:
    def __init__(self, kariton_order, dice):
        self.kariton_order = kariton_order
        self.dice = dice

    # æ´—ç‰Œ = ç‰Œã‚’æ··ãœã‚‹
    def shipai(self):
        tile_list = [t.strip() for t in tiles.split(",")]
        random.shuffle(tile_list)
        return tile_list

    # ç Œç‰Œ = å£ç‰Œã‚’ç©ã‚€
    def chipai(self, tile_list):
        for p in self.kariton_order.values():
            wall = Wall()
            for _ in range(17):
                upper, lower = tile_list.pop(0), tile_list.pop(0)
                wall.add_column(upper, lower)
            p.wall = wall

    # é–‹é–€ ï¼ åˆ‡ã‚Šå±±ã®ä½ç½®æ±ºå®š
    def kaimen(self, parent):
        target_side, total, d1, d2 = self.dice.roll_and_get_target(parent.seat)
        target = self.kariton_order[target_side]
        return target, total, d1, d2

# ===============================
# ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤éƒ¨
# ===============================
class Game:
    def __init__(self, logger, dice):
        self.logger = logger
        self.dice = dice
        self.players = PlayerFactory.create_players()
        self.seating = SeatingManager(self.players)
        self.phase = GamePhase.INIT
        self.log_manager = LogManager(logger)

    def run(self):
        self.phase = GamePhase.KARITON
        mixer = self.seating.decide_kariton()
        kariton_player = next(p for p in self.players if p.is_kariton)

        self.log_manager.log_title_and_contents(f"é¢¨ç‰Œã‚’æ··ãœã‚‹åèª‰ã‚ã‚‹è€…", mixer.name)
        self.log_manager.show_drawn_winds(self.players)  # ä»®æ±æ±ºã‚æ™‚ã«å„äººãŒå¼•ã„ãŸé¢¨ç‰Œã‚’è¡¨ç¤º
        self.log_manager.logger.log(
            f"\nä»®æ±ã¯ {kariton_player.name} ã§ã€ç¾åœ¨å¸­ã¯ {kariton_player.seat} â€¦â€¦")
        self.log_manager.log_title(f"ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯å–å¾—ã—ãŸé¢¨ç‰Œé€šã‚Šã«å¾Œç€å¸­ãã ã•ã„")
        self.log_manager.show_seating_by_initial_wind(self.seating.kariton_order)  # ç¾åœ¨ã®å¸­é †

        self.phase = GamePhase.TEMP_PARENT
        temp_parent, real_parent, d1, d2, rd1, rd2 = self.seating.decide_parent()

        # ã‚µã‚¤ã‚³ãƒ­ã®çµæœãªã©ã‚’è¡¨ç¤º
        self.log_manager.log_dice(
            "ä»®è¦ªæ±ºå®š", kariton_player.name, d1, d2, f"ä»®è¦ªã¯ {temp_parent.name} ")
        self.log_manager.log_dice(
            "è¦ªæ±ºå®š", temp_parent.name, rd1, rd2, f"è¦ªï¼ˆæ±å®¶ï¼‰ã¯ {real_parent.name} ")

        self.log_manager.log_title(f"å ´é¢¨ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¾ã—ãŸ")
        self.log_manager.show_seating_by_wind(self.seating.kariton_order)  # å¸­é †ã®è¡¨ç¤º

        self.phase = GamePhase.WALL_BUILD
        wall_mgr = WallManager(self.seating.kariton_order, self.dice)
        tiles = wall_mgr.shipai()
        self.log_manager.show_shipai_result(tiles)
        wall_mgr.chipai(tiles)
        self.log_manager.show_all_walls(self.seating.kariton_order)

        self.phase = GamePhase.KAIMEN
        target, total, d1, d2 = wall_mgr.kaimen(real_parent)

        self.log_manager.log_dice("é–‹é–€", real_parent.name, d1, d2,
                                  f"é–‹é–€ã¯ {target.name} ãŒç›®ã®å‰ã®å£ç‰Œã€å‘ã‹ã£ã¦ {total} åˆ—ç›®ã‹ã‚‰è¡Œã†â€¦â€¦")

        self.log_manager.show_kaimen_wall(target, total)

# ===============================
# è¡¨ç¤ºã®èª¿æ•´ã€€UIï¼ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å±¤
# ===============================
class LogManager:
    def __init__(self, logger):
        self.logger = logger

    def log_title(self, title):
        self.logger.log(f"\nâ”€â”€â”€ {title} â”€â”€â”€")

    def log_title_and_contents(self, title, contents):
        self.log_title(title)
        self.logger.log(f"\n" + contents)

    # ã€Œå¼•ã„ãŸé¢¨ç‰Œã€ã‚’é¢¨ã®ä¸¦ã³é †ã«ã‚½ãƒ¼ãƒˆè¡¨ç¤º
    def show_drawn_winds(self, players):
        self.log_title("å„ã€…ãŒå¼•ã„ãŸé¢¨ç‰Œ")
        sorted_players = sorted(
            players, key=lambda p: TableOrder.wind_order.index(p.initial_wind))
        self.logger.log(", ".join(f"{p.name}:{p.initial_wind}" for p in sorted_players))

    # å¸­è¡¨ç¤ºãƒ»å ´é¢¨è¡¨ç¤ºã‚’é¢¨ã®ä¸¦ã³é †ã«ã‚½ãƒ¼ãƒˆè¡¨ç¤º
    def show_seating_by_wind(self, kariton_order):
        sorted_items = sorted(
            kariton_order.items(),
            key=lambda item: TableOrder.wind_order.index(item[1].wind)
        )
        for side, player in sorted_items:
            self.logger.log(f"{side} {player.name} ({player.wind})")

    # å¸­è¡¨ç¤ºãƒ»å ´é¢¨è¡¨ç¤ºã‚’åˆæœŸé¢¨ã®ä¸¦ã³é †ã«ã‚½ãƒ¼ãƒˆè¡¨ç¤º
    def show_seating_by_initial_wind(self, kariton_order):
        sorted_items = sorted(
            kariton_order.items(),
            key=lambda item: TableOrder.wind_order.index(item[1].initial_wind)
        )
        for side, player in sorted_items:
            self.logger.log(f"{side} {player.name} ({player.initial_wind})")

    # ã‚µã‚¤ã‚³ãƒ­æ¼”å‡º
    def show_dice(self, roller_name, die1, die2):
        self.logger.log(f"â”€â”€â”€ {roller_name} ãŒã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã‚Šã¾ã—ãŸâ€¦â€¦")
        self.logger.log(f" {die1}ã€{die2} ï¼ å‡ºç›®åˆè¨ˆ {die1 + die2} â”€â”€â”€")

    # æ´—ç‰Œçµæœè¡¨ç¤º
    def show_shipai_result(self, tile_list):
        self.log_title("æ´—ç‰Œ")
        self.logger.log(f"ç¾åœ¨ã®ç‰Œä¸¦ã³: {', '.join(tile_list)}")
        self.logger.log(
            "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")

    # å£ç‰Œã®è¡¨ç¤º
    def show_wall(self, player):
        self.logger.log(f"ã€{player.wind}å®¶ã€€{player.name}ï¼ˆ{player.seat}å¸­ï¼‰ã®å£ç‰Œã€‘")
        self.logger.log("ä¸Šæ®µï¼š" + ", ".join(player.wall.upper_row()))
        self.logger.log("ä¸‹æ®µï¼š" + ", ".join(player.wall.lower_row()))
        self.logger.log(
            "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")

    # å…¨å“¡åˆ†ã®å£ç‰Œã‚’é¢¨ã®ä¸¦ã³é †ã§è¡¨ç¤º
    def show_all_walls(self, kariton_order):
        for wind in TableOrder.wind_order:
            for side, player in kariton_order.items():
                if player.wind == wind:
                    self.show_wall(player)

    # é–‹é–€è¡¨ç¤º
    def show_kaimen_wall(self, player, total):
        self.log_title("é–‹é–€")
        idx = len(player.wall.columns) - total

        upper = player.wall.upper_row()
        lower = player.wall.lower_row()

        upper.insert(idx, " é–‹é–€ä½ç½® ")
        lower.insert(idx, " é–‹é–€ä½ç½® ")

        self.logger.log(f"ã€{player.wind}å®¶ã€€{player.name}ï¼ˆ{player.seat}å¸­ï¼‰ã®å£ç‰Œã€‘")
        self.logger.log("ä¸Šæ®µï¼š" + ", ".join(upper))
        self.logger.log("ä¸‹æ®µï¼š" + ", ".join(lower))

    # ã‚µã‚¤ã‚³ãƒ­æ¼”å‡º2 ç›®çš„ã®ç‚ºã«ã€åå‰ãŒã€ã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã‚Šã€å‡ºç›®äºŒã¤ã¯ã“ã‚Œã§åˆè¨ˆã¯ã“ã‚Œã§ã€çµæœã“ã†ã•
    def log_dice(self, roll_purpose, roller_name, die1, die2, result_message):
        self.logger.log(f"\nâ”€â”€â”€ {roll_purpose} ã®ç‚ºã« {roller_name} ãŒã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã‚Šã¾ã—ãŸâ€¦â€¦")
        self.logger.log(f"{die1}ã€{die2} ï¼ å‡ºç›®åˆè¨ˆ {die1 + die2}")
        self.logger.log(result_message)

# ===============================
# ãƒ¡ã‚¤ãƒ³å‡¦ç†
# ===============================
if __name__ == "__main__":
    Game(logger, Dice()).run()
